<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入Flink源码 - Checkpoint状态恢复流程 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Weizhe Huang" /><meta name="description" content="flink本身有重启机制，本文分析的是通过flink run -s 命令恢复任务的流程。 flink checkpoint文件是自描述的，_metadata文件保存" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.64.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/%E6%B7%B1%E5%85%A5flink%E6%BA%90%E7%A0%81-checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入Flink源码 - Checkpoint状态恢复流程" />
<meta property="og:description" content="flink本身有重启机制，本文分析的是通过flink run -s 命令恢复任务的流程。 flink checkpoint文件是自描述的，_metadata文件保存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/%E6%B7%B1%E5%85%A5flink%E6%BA%90%E7%A0%81-checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/" />
<meta property="article:published_time" content="2020-03-20T15:11:40+08:00" />
<meta property="article:modified_time" content="2020-03-20T15:11:40+08:00" />
<meta itemprop="name" content="深入Flink源码 - Checkpoint状态恢复流程">
<meta itemprop="description" content="flink本身有重启机制，本文分析的是通过flink run -s 命令恢复任务的流程。 flink checkpoint文件是自描述的，_metadata文件保存">
<meta itemprop="datePublished" content="2020-03-20T15:11:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-20T15:11:40&#43;08:00" />
<meta itemprop="wordCount" content="13726">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入Flink源码 - Checkpoint状态恢复流程"/>
<meta name="twitter:description" content="flink本身有重启机制，本文分析的是通过flink run -s 命令恢复任务的流程。 flink checkpoint文件是自描述的，_metadata文件保存"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入Flink源码 - Checkpoint状态恢复流程</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-20 </span>
        <div class="post-category">
            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"> 大数据 </a>
            <a href="/categories/flink/"> flink </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#jobmanager端">JobManager端</a>
      <ul>
        <li><a href="#文件元信息的重分配">文件元信息的重分配</a></li>
        <li><a href="#并行度未发生改变">并行度未发生改变</a></li>
        <li><a href="#并行度发生改变">并行度发生改变</a></li>
        <li><a href="#将文件元信息发往taskexecutor端">将文件元信息发往TaskExecutor端</a></li>
      </ul>
    </li>
    <li><a href="#taskexecutor端">TaskExecutor端</a>
      <ul>
        <li><a href="#tdd对象如何被封装和传递">tdd对象如何被封装和传递</a></li>
        <li><a href="#状态恢复的核心逻辑">状态恢复的核心逻辑</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>flink本身有重启机制，本文分析的是通过flink run -s <savepointPath>命令恢复任务的流程。</p>
<p>flink checkpoint文件是自描述的，_metadata文件保存了所有状态数据文件的路径、文件大小、状态数据在文件的位置等信息，状态数据文件的开头保存了该文件中状态数据的序列化信息，通过解析可以得到序列化器对象，直接反序列化文件内容。整个解析过程可以不需要运行时信息。</p>
<p>在checkpoint的写入过程中，是每个Task独自生成状态数据文件，然后最终由JobManager端将这些文件信息写入到_metadata文件中，所以在解析的过程中也是从JobManager端开始解析 _metadata文件，然后在Task端读取数据文件进行恢复。</p>
<p>本文将_metadata中的数据叫做“<strong>文件元信息</strong>”，状态数据文件中关于序列化器的信息称为“<strong>状态元信息</strong>”。</p>
<h2 id="jobmanager端">JobManager端</h2>
<p>在创建ExecutionGraph时，会调用LegacyScheduler.createAndRestoreExecutionGraph方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">ExecutionGraph</span> <span class="nf">createAndRestoreExecutionGraph</span><span class="o">(</span>
      <span class="n">JobManagerJobMetricGroup</span> <span class="n">currentJobManagerJobMetricGroup</span><span class="o">,</span>
      <span class="n">ShuffleMaster</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">shuffleMaster</span><span class="o">,</span>
      <span class="n">PartitionTracker</span> <span class="n">partitionTracker</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

	<span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">checkpointCoordinator</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">checkpointCoordinator</span><span class="o">.</span><span class="na">restoreLatestCheckpointedState</span><span class="o">(</span>
         <span class="n">newExecutionGraph</span><span class="o">.</span><span class="na">getAllVertices</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="kc">false</span><span class="o">,</span>
         <span class="kc">false</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        
         <span class="n">tryRestoreExecutionGraphFromSavepoint</span><span class="o">(</span><span class="n">newExecutionGraph</span><span class="o">,</span> <span class="n">jobGraph</span><span class="o">.</span><span class="na">getSavepointRestoreSettings</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>

   <span class="k">return</span> <span class="n">newExecutionGraph</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在指定了 -s 参数从checkpoint/savepoint文件恢复的情况下，会进入到tryRestoreExecutionGraphFromSavepoint方法。最终进入到CheckpointCoordinator.restoreSavepoint方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">restoreSavepoint</span><span class="o">(</span>
      <span class="n">String</span> <span class="n">savepointPointer</span><span class="o">,</span>
      <span class="kt">boolean</span> <span class="n">allowNonRestored</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">,</span>
      <span class="n">ClassLoader</span> <span class="n">userClassLoader</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
 
   <span class="n">CompletedCheckpoint</span> <span class="n">savepoint</span> <span class="o">=</span> <span class="n">Checkpoints</span><span class="o">.</span><span class="na">loadAndValidateCheckpoint</span><span class="o">(</span>
         <span class="n">job</span><span class="o">,</span> <span class="n">tasks</span><span class="o">,</span> <span class="n">checkpointLocation</span><span class="o">,</span> <span class="n">userClassLoader</span><span class="o">,</span> <span class="n">allowNonRestored</span><span class="o">)</span><span class="o">;</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="k">return</span> <span class="n">restoreLatestCheckpointedState</span><span class="o">(</span><span class="n">tasks</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">allowNonRestored</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>通过Checkpoints.loadAndValidateCheckpoint方法获得CompletedCheckpoint对象。Checkpoints.loadAndValidateCheckpoint方法内部是通过Checkpoints.loadCheckpointMetadata方法获得了一个Savepoint对象，这个对象中包含了_metadata文件中的信息。主要信息都在operatorStates字段中。</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/rawCheckpointMetadata.png" alt="rawCheckpointMetadata"></p>
<p>这里详细解释一下该字段包含的内容。</p>
<p>这个列表中有三个元素，表示有三个算子。每个OperatorState中的operatorSubtaskStates字段中保存了信息。该字段有两个元素，表示这个算子有两个并行度，它维护了每个并行实例中的信息。在其中的value中，保存了各种类型的状态信息。进入到managedOperatorState中，这个字段是只有一个元素的Collection，所以直接点开第一个元素来看。这是一个OperatorStreamStateHandle对象，其中有stateNameToPartitionOffsets和delegateStateHandle字段，前者包含了该算子在该并行实例中每个状态在文件中位置和状态模式（UNION），后者包含文件的路径。</p>
<p>由此可以看出，此处的信息是按照每个算子的每个并行度来维护的。另外还能看到每个算子的并行度和最大并行度。这些信息在之后状态重新分配的过程中都有用。这些信息最后被封装为了CompletedCheckpoint对象。</p>
<p>进入到restoreLatestCheckpointedState方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">restoreLatestCheckpointedState</span><span class="o">(</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">,</span>
      <span class="kt">boolean</span> <span class="n">errorIfNoCheckpoint</span><span class="o">,</span>
      <span class="kt">boolean</span> <span class="n">allowNonRestoredState</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="c1">// 1.取出之前封装的CompletedCheckpoint对象。
</span><span class="c1"></span>      <span class="n">CompletedCheckpoint</span> <span class="n">latest</span> <span class="o">=</span> <span class="n">completedCheckpointStore</span><span class="o">.</span><span class="na">getLatestCheckpoint</span><span class="o">(</span><span class="n">isPreferCheckpointForRecovery</span><span class="o">)</span><span class="o">;</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="c1">// 2.取出其中的状态信息。也就是刚才分析的那个对象。
</span><span class="c1"></span>      <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">,</span> <span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">operatorStates</span> <span class="o">=</span> <span class="n">latest</span><span class="o">.</span><span class="na">getOperatorStates</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

      <span class="c1">// 3.将状态信息分配到本次的tasks中。
</span><span class="c1"></span>      <span class="n">StateAssignmentOperation</span> <span class="n">stateAssignmentOperation</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">StateAssignmentOperation</span><span class="o">(</span><span class="n">latest</span><span class="o">.</span><span class="na">getCheckpointID</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">tasks</span><span class="o">,</span> <span class="n">operatorStates</span><span class="o">,</span> <span class="n">allowNonRestoredState</span><span class="o">)</span><span class="o">;</span>
      <span class="n">stateAssignmentOperation</span><span class="o">.</span><span class="na">assignStates</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上面已经从_metadata文件中读取出了文件元信息，这些信息需要跟本次的tasks对应起来，这样这些task分配到TaskExecutor中就知道去哪个文件读取状态数据并恢复。具体逻辑在assignStates方法中。</p>
<p>这个tasks字段是一个Map，维护了JobVertexID与具体的ExecutionJobVertex的关系。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>回顾ExecutionGraph：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/ExecutionGraph.png" alt="ExecutionGraph"></p>
<p>一个ExecutionVertex表示一个并行实例，一个算子（或多个chain起来的算子）的所有并行实例合在一起为一个ExecutionJobVertex。assignStates方法的整体逻辑，就是遍历每一个ExecutionJobVertex。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">assignStates</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">,</span> <span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">localOperators</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">operatorStates</span><span class="o">)</span><span class="o">;</span>

   <span class="n">checkStateMappingCompleteness</span><span class="o">(</span><span class="n">allowNonRestoredState</span><span class="o">,</span> <span class="n">operatorStates</span><span class="o">,</span> <span class="n">tasks</span><span class="o">)</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="n">task</span> <span class="o">:</span> <span class="k">this</span><span class="o">.</span><span class="na">tasks</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      <span class="kd">final</span> <span class="n">ExecutionJobVertex</span> <span class="n">executionJobVertex</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
		 <span class="c1">// 1.获取这个ExecutionJobVertex中包含的算子ID。
</span><span class="c1"></span>      <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="n">operatorIDs</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getOperatorIDs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="n">altOperatorIDs</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getUserDefinedOperatorIDs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     
      <span class="c1">// 2.创建一个保存OperatorState的列表，用来存放从_metadata文件中读取出来的信息。
</span><span class="c1"></span>      <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">operatorStates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">operatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="kt">boolean</span> <span class="n">statelessTask</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">operatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">x</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">OperatorID</span> <span class="n">operatorID</span> <span class="o">=</span> <span class="n">altOperatorIDs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span>
            <span class="o">?</span> <span class="n">operatorIDs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
            <span class="o">:</span> <span class="n">altOperatorIDs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">x</span><span class="o">)</span><span class="o">;</span>

         <span class="c1">// 3.根据算子ID取出这个ExecutionJobVertex负责的每个OperatorState。
</span><span class="c1"></span>         <span class="n">OperatorState</span> <span class="n">operatorState</span> <span class="o">=</span> <span class="n">localOperators</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">operatorID</span><span class="o">)</span><span class="o">;</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">operatorState</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">operatorState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorState</span><span class="o">(</span>
               <span class="n">operatorID</span><span class="o">,</span>
               <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
               <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
         <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">statelessTask</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="c1">// 4.添加进上面的列表中。
</span><span class="c1"></span>         <span class="n">operatorStates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">operatorState</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">statelessTask</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// skip tasks where no operator has any state
</span><span class="c1"></span>         <span class="k">continue</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// 5.把从文件中读取出来的信息分配到本次遍历的ExecutionJobVertex中。
</span><span class="c1"></span>      <span class="n">assignAttemptState</span><span class="o">(</span><span class="n">task</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">operatorStates</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>进入到assignAttemptState方法。接下来分析的逻辑都发生在对一个ExecutionJobVertex的处理中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">assignAttemptState</span><span class="o">(</span><span class="n">ExecutionJobVertex</span> <span class="n">executionJobVertex</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">operatorStates</span><span class="o">)</span> <span class="o">{</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="n">operatorIDs</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getOperatorIDs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="n">checkParallelismPreconditions</span><span class="o">(</span><span class="n">operatorStates</span><span class="o">,</span> <span class="n">executionJobVertex</span><span class="o">)</span><span class="o">;</span>

   <span class="kt">int</span> <span class="n">newParallelism</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyGroupRange</span><span class="o">&gt;</span> <span class="n">keyGroupPartitions</span> <span class="o">=</span> <span class="n">createKeyGroupPartitions</span><span class="o">(</span>
      <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

   <span class="kd">final</span> <span class="kt">int</span> <span class="n">expectedNumberOfSubTasks</span> <span class="o">=</span> <span class="n">newParallelism</span> <span class="o">*</span> <span class="n">operatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="cm">/*
</span><span class="cm">    * Redistribute ManagedOperatorStates and RawOperatorStates from old parallelism to new parallelism.
</span><span class="cm">    *
</span><span class="cm">    * The old ManagedOperatorStates with old parallelism 3:
</span><span class="cm">    *
</span><span class="cm">    *        parallelism0 parallelism1 parallelism2
</span><span class="cm">    * op0   states0,0    state0,1    state0,2
</span><span class="cm">    * op1
</span><span class="cm">    * op2   states2,0    state2,1    state1,2
</span><span class="cm">    * op3   states3,0    state3,1     state3,2
</span><span class="cm">    *
</span><span class="cm">    * The new ManagedOperatorStates with new parallelism 4:
</span><span class="cm">    *
</span><span class="cm">    *        parallelism0 parallelism1 parallelism2 parallelism3
</span><span class="cm">    * op0   state0,0    state0,1        state0,2       state0,3
</span><span class="cm">    * op1
</span><span class="cm">    * op2   state2,0    state2,1        state2,2       state2,3
</span><span class="cm">    * op3   state3,0    state3,1        state3,2       state3,3
</span><span class="cm">    */</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedOperatorStates</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawOperatorStates</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>

   <span class="n">reDistributePartitionableStates</span><span class="o">(</span>
      <span class="n">operatorStates</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">,</span>
      <span class="n">operatorIDs</span><span class="o">,</span>
      <span class="n">newManagedOperatorStates</span><span class="o">,</span>
      <span class="n">newRawOperatorStates</span><span class="o">)</span><span class="o">;</span>

   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedKeyedState</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawKeyedState</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>

   <span class="n">reDistributeKeyedStates</span><span class="o">(</span>
      <span class="n">operatorStates</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">,</span>
      <span class="n">operatorIDs</span><span class="o">,</span>
      <span class="n">keyGroupPartitions</span><span class="o">,</span>
      <span class="n">newManagedKeyedState</span><span class="o">,</span>
      <span class="n">newRawKeyedState</span><span class="o">)</span><span class="o">;</span>

   <span class="cm">/*
</span><span class="cm">    *  An executionJobVertex&#39;s all state handles needed to restore are something like a matrix
</span><span class="cm">    *
</span><span class="cm">    *        parallelism0 parallelism1 parallelism2 parallelism3
</span><span class="cm">    * op0   sh(0,0)     sh(0,1)       sh(0,2)     sh(0,3)
</span><span class="cm">    * op1   sh(1,0)    sh(1,1)      sh(1,2)     sh(1,3)
</span><span class="cm">    * op2   sh(2,0)    sh(2,1)      sh(2,2)    sh(2,3)
</span><span class="cm">    * op3   sh(3,0)    sh(3,1)      sh(3,2)    sh(3,3)
</span><span class="cm">    *
</span><span class="cm">    */</span>
   <span class="n">assignTaskStateToExecutionJobVertices</span><span class="o">(</span>
      <span class="n">executionJobVertex</span><span class="o">,</span>
      <span class="n">newManagedOperatorStates</span><span class="o">,</span>
      <span class="n">newRawOperatorStates</span><span class="o">,</span>
      <span class="n">newManagedKeyedState</span><span class="o">,</span>
      <span class="n">newRawKeyedState</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法的每一步都很重要。下面逐步分析。</p>
<p>首先获取ExecutionJobVertex对象的所有算子ID。这是从本次任务中获取的，而不是从文件获取的。然后调用checkParallelismPreconditions方法进行并行度和最大并行度的验证。会对每个OperatorState进行验证。每个OperatorState就表示一个算子的信息。所以这里要验证的，就是从文件中读取的这个ExecutionJobVertex中对应的所有算子的并行度和最大并行度是否符合本次任务运行时生成的这个ExecutionJobVertex的整体并行度和最大并行度。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkParallelismPreconditions</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">operatorStates</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span> <span class="n">executionJobVertex</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">for</span> <span class="o">(</span><span class="n">OperatorState</span> <span class="n">operatorState</span> <span class="o">:</span> <span class="n">operatorStates</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkParallelismPreconditions</span><span class="o">(</span><span class="n">operatorState</span><span class="o">,</span> <span class="n">executionJobVertex</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">checkParallelismPreconditions</span><span class="o">(</span><span class="n">OperatorState</span> <span class="n">operatorState</span><span class="o">,</span> <span class="n">ExecutionJobVertex</span> <span class="n">executionJobVertex</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;The state for task &#34;</span> <span class="o">+</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getJobVertexId</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span>
         <span class="s">&#34; can not be restored. The maximum parallelism (&#34;</span> <span class="o">+</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span>
         <span class="s">&#34;) of the restored state is lower than the configured parallelism (&#34;</span> <span class="o">+</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span>
         <span class="s">&#34;). Please reduce the parallelism of the task to be lower or equal to the maximum parallelism.&#34;</span>
      <span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">executionJobVertex</span><span class="o">.</span><span class="na">isMaxParallelismConfigured</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">LOG</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Overriding maximum parallelism for JobVertex {} from {} to {}&#34;</span><span class="o">,</span>
            <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getJobVertexId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

         <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">setMaxParallelism</span><span class="o">(</span><span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;The maximum parallelism (&#34;</span> <span class="o">+</span>
            <span class="n">operatorState</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;) with which the latest &#34;</span> <span class="o">+</span>
            <span class="s">&#34;checkpoint of the execution job vertex &#34;</span> <span class="o">+</span> <span class="n">executionJobVertex</span> <span class="o">+</span>
            <span class="s">&#34; has been taken and the current maximum parallelism (&#34;</span> <span class="o">+</span>
            <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span> <span class="o">+</span> <span class="s">&#34;) changed. This &#34;</span> <span class="o">+</span>
            <span class="s">&#34;is currently not supported.&#34;</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果最大并行度小于并行度，那么直接抛异常。当最大并行度发生了变化时，如果ExecutionJobVertex的最大并行度还没有经过设置，则将文件中读取的这个值赋给它；否则直接抛异常。从这里可以看出，最大并行度一般是不能修改的。关于并行度和最大并行度之间的作用和关系会在另外的文章中详细分析。</p>
<p>回到assignAttemptState方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kt">int</span> <span class="n">newParallelism</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">KeyGroupRange</span><span class="o">&gt;</span> <span class="n">keyGroupPartitions</span> <span class="o">=</span> <span class="n">createKeyGroupPartitions</span><span class="o">(</span>
   <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getMaxParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
   <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

<span class="kd">final</span> <span class="kt">int</span> <span class="n">expectedNumberOfSubTasks</span> <span class="o">=</span> <span class="n">newParallelism</span> <span class="o">*</span> <span class="n">operatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>从本次任务的ExecutionJobVertex中获取到本次的并行度。这个并行度可能与之前的不同，所以属性名取为newParrellelism。利用最大并行度和新的并行度得到KeyGroupRange的范围。KeyGroupRange的相关知识也会在分析并行度和最大并行度的文章中一起分析。本文只分析整体流程，所以暂时不用理解它的概念，接下来的分析也会跳过相关的步骤。</p>
<p>然后用新并行度乘以算子的个数，得到一个值。这个值的个数表示该ExecutionJobVertex的所有算子的并行实例加在一起的个数。</p>
<p>接下来创建该大小的两个Map，然后调用reDistributePartitionableStates方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedOperatorStates</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawOperatorStates</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>

<span class="n">reDistributePartitionableStates</span><span class="o">(</span>
   <span class="n">operatorStates</span><span class="o">,</span>
   <span class="n">newParallelism</span><span class="o">,</span>
   <span class="n">operatorIDs</span><span class="o">,</span>
   <span class="n">newManagedOperatorStates</span><span class="o">,</span>
   <span class="n">newRawOperatorStates</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>reDistributePartitionableStates方法针对的是OperatorState（这里指的是与KeyedState对应的那个State类型，而不是上文中的那个类）的重分配。这个方法结束后会调用reDistributeKeyedStates方法对KeyedState进行重分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedKeyedState</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawKeyedState</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>

<span class="n">reDistributeKeyedStates</span><span class="o">(</span>
   <span class="n">operatorStates</span><span class="o">,</span>
   <span class="n">newParallelism</span><span class="o">,</span>
   <span class="n">operatorIDs</span><span class="o">,</span>
   <span class="n">keyGroupPartitions</span><span class="o">,</span>
   <span class="n">newManagedKeyedState</span><span class="o">,</span>
   <span class="n">newRawKeyedState</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>最后将这四个Map作为参数传入assignTaskStateToExecutionJobVertices方法中，进行一些简单的设置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">assignTaskStateToExecutionJobVertices</span><span class="o">(</span>
   <span class="n">executionJobVertex</span><span class="o">,</span>
   <span class="n">newManagedOperatorStates</span><span class="o">,</span>
   <span class="n">newRawOperatorStates</span><span class="o">,</span>
   <span class="n">newManagedKeyedState</span><span class="o">,</span>
   <span class="n">newRawKeyedState</span><span class="o">,</span>
   <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>所以整个逻辑的核心就是reDistributePartitionableStates和reDistributeKeyedStates方法。</p>
<p>本文仅分析reDistributePartitionableStates方法。而reDistributeKeyedStates方法也留在分析并行度和最大并行度一文中。</p>
<h3 id="文件元信息的重分配">文件元信息的重分配</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">reDistributePartitionableStates</span><span class="o">(</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">oldOperatorStates</span><span class="o">,</span>
      <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">,</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="n">newOperatorIDs</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedOperatorStates</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawOperatorStates</span><span class="o">)</span> <span class="o">{</span>

   <span class="n">checkState</span><span class="o">(</span><span class="n">newOperatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">oldOperatorStates</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="s">&#34;This method still depends on the order of the new and old operators&#34;</span><span class="o">)</span><span class="o">;</span>

   <span class="c1">// The nested list wraps as the level of operator -&gt; subtask -&gt; state object collection
</span><span class="c1"></span>   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">oldManagedOperatorStates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">oldOperatorStates</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">oldRawOperatorStates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">oldOperatorStates</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="c1">// 1.将oldOperatorStates中的数据拆分到oldManagedOperatorStates和oldRawOperatorStates。
</span><span class="c1"></span>   <span class="n">splitManagedAndRawOperatorStates</span><span class="o">(</span><span class="n">oldOperatorStates</span><span class="o">,</span> <span class="n">oldManagedOperatorStates</span><span class="o">,</span> <span class="n">oldRawOperatorStates</span><span class="o">)</span><span class="o">;</span>
   <span class="n">OperatorStateRepartitioner</span> <span class="n">opStateRepartitioner</span> <span class="o">=</span> <span class="n">RoundRobinOperatorStateRepartitioner</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">;</span>

   <span class="c1">// 2.遍历每个算子，将oldManagedOperatorStates和oldRawOperatorStates中对应的数据存入
</span><span class="c1"></span>   <span class="c1">// newManagedOperatorStates和newRawOperatorStates中。
</span><span class="c1"></span>   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">operatorIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">operatorIndex</span> <span class="o">&lt;</span> <span class="n">newOperatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">operatorIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">OperatorState</span> <span class="n">operatorState</span> <span class="o">=</span> <span class="n">oldOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">;</span>
      <span class="kt">int</span> <span class="n">oldParallelism</span> <span class="o">=</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

      <span class="n">OperatorID</span> <span class="n">operatorID</span> <span class="o">=</span> <span class="n">newOperatorIDs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">;</span>

      <span class="n">newManagedOperatorStates</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">applyRepartitioner</span><span class="o">(</span>
         <span class="n">operatorID</span><span class="o">,</span>
         <span class="n">opStateRepartitioner</span><span class="o">,</span>
         <span class="n">oldManagedOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">,</span>
         <span class="n">oldParallelism</span><span class="o">,</span>
         <span class="n">newParallelism</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

      <span class="n">newRawOperatorStates</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">applyRepartitioner</span><span class="o">(</span>
         <span class="n">operatorID</span><span class="o">,</span>
         <span class="n">opStateRepartitioner</span><span class="o">,</span>
         <span class="n">oldRawOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">,</span>
         <span class="n">oldParallelism</span><span class="o">,</span>
         <span class="n">newParallelism</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>传入的参数有oldOperatorStates、newManagedOperatorStates、newRawOperatorStates，方法中构造的对象有oldManagedOperatorStates、oldRawOperatorStates。可以初步分析，这个方法做的事情，就是将oldOperatorStates的数据拆分到oldManagedOperatorStates和oldRawOperatorStates中，然后将oldManagedOperatorStates和oldRawOperatorStates中的数据分别做一些处理，分别存入newManagedOperatorStates和newRawOperatorStates中。</p>
<p>其中拆分的步骤由splitManagedAndRawOperatorStates方法完成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">splitManagedAndRawOperatorStates</span><span class="o">(</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorState</span><span class="o">&gt;</span> <span class="n">operatorStates</span><span class="o">,</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">managedOperatorStates</span><span class="o">,</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">rawOperatorStates</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">for</span> <span class="o">(</span><span class="n">OperatorState</span> <span class="n">operatorState</span> <span class="o">:</span> <span class="n">operatorStates</span><span class="o">)</span> <span class="o">{</span>

      <span class="kd">final</span> <span class="kt">int</span> <span class="n">parallelism</span> <span class="o">=</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">managedOpStatePerSubtasks</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">parallelism</span><span class="o">)</span><span class="o">;</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">rawOpStatePerSubtasks</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">parallelism</span><span class="o">)</span><span class="o">;</span>

      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">subTaskIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">subTaskIndex</span> <span class="o">&lt;</span> <span class="n">parallelism</span><span class="o">;</span> <span class="n">subTaskIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">OperatorSubtaskState</span> <span class="n">operatorSubtaskState</span> <span class="o">=</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getState</span><span class="o">(</span><span class="n">subTaskIndex</span><span class="o">)</span><span class="o">;</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">operatorSubtaskState</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">managedOpStatePerSubtasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="n">rawOpStatePerSubtasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
         <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">managed</span> <span class="o">=</span> <span class="n">operatorSubtaskState</span><span class="o">.</span><span class="na">getManagedOperatorState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">operatorSubtaskState</span><span class="o">.</span><span class="na">getRawOperatorState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

            <span class="n">managedOpStatePerSubtasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">managed</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="n">rawOpStatePerSubtasks</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">raw</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
         <span class="o">}</span>
      <span class="o">}</span>
      <span class="n">managedOperatorStates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">managedOpStatePerSubtasks</span><span class="o">)</span><span class="o">;</span>
      <span class="n">rawOperatorStates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">rawOpStatePerSubtasks</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到managedOperatorStates和rawOperatorStates的数据类型是三层列表，非常复杂。根据上面的注释得知结构为：</p>
<p>operator -&gt; subtask -&gt; state object collection</p>
<p>该方法遍历operatorStates，获取并行度后遍历每个并行实例。回顾operatorStates中的内容：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/split_operatorStates.png" alt="split_operatorStates"></p>
<p>通过operatorState.getState方法得到的就是operatorSubtaskStates中的一个元素，即一个OperatorSubtaskState对象。表示一个并行实例中维护的信息。</p>
<p>而operatorSubtaskStates中的信息如下：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/operatorSubtaskStates.png" alt="operatorSubtaskStates"></p>
<p>它维护了4种State，而每种State又是一个StateObjectCollection类型，里面只包含一个元素。所以operatorStates本身就是三层结构，splitManagedAndRawOperatorStates方法只是把关键的信息提取出来，去掉了多余的信息，将它们重新组装成了三层List的结构。</p>
<p>拆分完后得到：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/managedOperatorStates.png" alt="managedOperatorStates"></p>
<p>回到reDistributePartitionableStates方法中，接下来又遍历每个算子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">operatorIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">operatorIndex</span> <span class="o">&lt;</span> <span class="n">newOperatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">operatorIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">OperatorState</span> <span class="n">operatorState</span> <span class="o">=</span> <span class="n">oldOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">;</span>
   <span class="kt">int</span> <span class="n">oldParallelism</span> <span class="o">=</span> <span class="n">operatorState</span><span class="o">.</span><span class="na">getParallelism</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="n">OperatorID</span> <span class="n">operatorID</span> <span class="o">=</span> <span class="n">newOperatorIDs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">;</span>

   <span class="n">newManagedOperatorStates</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">applyRepartitioner</span><span class="o">(</span>
      <span class="n">operatorID</span><span class="o">,</span>
      <span class="n">opStateRepartitioner</span><span class="o">,</span>
      <span class="n">oldManagedOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">,</span>
      <span class="n">oldParallelism</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="n">newRawOperatorStates</span><span class="o">.</span><span class="na">putAll</span><span class="o">(</span><span class="n">applyRepartitioner</span><span class="o">(</span>
      <span class="n">operatorID</span><span class="o">,</span>
      <span class="n">opStateRepartitioner</span><span class="o">,</span>
      <span class="n">oldRawOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">operatorIndex</span><span class="o">)</span><span class="o">,</span>
      <span class="n">oldParallelism</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以直接看出关键步骤是applyRepartitioner方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">applyRepartitioner</span><span class="o">(</span>
   <span class="n">OperatorID</span> <span class="n">operatorID</span><span class="o">,</span>
   <span class="n">OperatorStateRepartitioner</span> <span class="n">opStateRepartitioner</span><span class="o">,</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">chainOpParallelStates</span><span class="o">,</span>
   <span class="kt">int</span> <span class="n">oldParallelism</span><span class="o">,</span>
   <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">)</span> <span class="o">{</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">states</span> <span class="o">=</span> <span class="n">applyRepartitioner</span><span class="o">(</span>
      <span class="n">opStateRepartitioner</span><span class="o">,</span>
      <span class="n">chainOpParallelStates</span><span class="o">,</span>
      <span class="n">oldParallelism</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

   <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">states</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">subtaskIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">subtaskIndex</span> <span class="o">&lt;</span> <span class="n">states</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">subtaskIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">checkNotNull</span><span class="o">(</span><span class="n">states</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="s">&#34;states.get(subtaskIndex) is null&#34;</span><span class="o">)</span><span class="o">;</span>
      <span class="n">result</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">OperatorInstanceID</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">,</span> <span class="n">operatorID</span><span class="o">)</span><span class="o">,</span> <span class="n">states</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法的返回结果是Map&lt;OperatorInstanceID, List&lt;OperatorStateHandle&gt;&gt;，这也就是外层StateAssignmentOperation.assignAttemptState方法中那4个Map的数据类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedOperatorStates</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawOperatorStates</span> <span class="o">=</span>
   <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newManagedKeyedState</span> <span class="o">=</span>
	<span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">newRawKeyedState</span> <span class="o">=</span>
	<span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">expectedNumberOfSubTasks</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>OperatorInstanceID就是一个并行实例的ID，因此这些Map维护的就是每个新的并行实例所负责的文件元信息。</p>
<p>在applyRepartitioner方法中，又会进入一个重载的applyRepartitioner方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">applyRepartitioner</span><span class="o">(</span>
   <span class="n">OperatorStateRepartitioner</span> <span class="n">opStateRepartitioner</span><span class="o">,</span>
   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">chainOpParallelStates</span><span class="o">,</span>
   <span class="kt">int</span> <span class="n">oldParallelism</span><span class="o">,</span>
   <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">chainOpParallelStates</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyList</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">return</span> <span class="n">opStateRepartitioner</span><span class="o">.</span><span class="na">repartitionState</span><span class="o">(</span>
      <span class="n">chainOpParallelStates</span><span class="o">,</span>
      <span class="n">oldParallelism</span><span class="o">,</span>
      <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>参数中，chainOpParallelStates就是这个算子维护的文件元信息。进入到repartitionState方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">repartitionState</span><span class="o">(</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">previousParallelSubtaskStates</span><span class="o">,</span>
      <span class="kt">int</span> <span class="n">oldParallelism</span><span class="o">,</span>
      <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">)</span> <span class="o">{</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">mergeMapList</span><span class="o">;</span>
  
   <span class="k">if</span> <span class="o">(</span><span class="n">newParallelism</span> <span class="o">=</span><span class="o">=</span> <span class="n">oldParallelism</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 情况一：并行度未发生改变。
</span><span class="c1"></span>      <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">unionStates</span> <span class="o">=</span> <span class="n">collectUnionStates</span><span class="o">(</span><span class="n">previousParallelSubtaskStates</span><span class="o">)</span><span class="o">;</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">unionStates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">previousParallelSubtaskStates</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="n">mergeMapList</span> <span class="o">=</span> <span class="n">initMergeMapList</span><span class="o">(</span><span class="n">previousParallelSubtaskStates</span><span class="o">)</span><span class="o">;</span>

      <span class="n">repartitionUnionState</span><span class="o">(</span><span class="n">unionStates</span><span class="o">,</span> <span class="n">mergeMapList</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 情况二：并行度发生改变。
</span><span class="c1"></span>
      <span class="n">GroupByStateNameResults</span> <span class="n">nameToStateByMode</span> <span class="o">=</span> <span class="n">groupByStateMode</span><span class="o">(</span><span class="n">previousParallelSubtaskStates</span><span class="o">)</span><span class="o">;</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="n">mergeMapList</span> <span class="o">=</span>
         <span class="n">repartition</span><span class="o">(</span><span class="n">nameToStateByMode</span><span class="o">,</span> <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mergeMapList</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">mergeMapList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">.</span><span class="na">values</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>repartitionState方法将情况分为两种：并行度未发生改变和发生改变。我们先分析完并行度未发生改变时的整个重分配流程，再回过头来分析并行度改变时的重分配。</p>
<h3 id="并行度未发生改变">并行度未发生改变</h3>
<p>当并行度未发生改变时，只会将模式为UNION的状态进行重分配。</p>
<p>对于OperatorState（与KeyedState类型对应）来说，有三种模式：SPLIT_DISTRIBUTE、UNION、BROADCAST。三种模式意味着在Job恢复过程中，状态会按照不同的分配策略重新分配到各并行实例中，分别对应下图从左到右三种策略。</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/StateType.jpg" alt="StateType"></p>
<p>UNION模式会将所有状态元素全部分配给新的Task。</p>
<p>先调用collectUnionStates方法将每个并行实例中的UNION模式的状态取出来，将其存放在unionStates这个Map中。这个Map的key是状态名，value是一个List，存放的是每个并行实例中的文件元信息，但是是以Tuple2的形式保存的。</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/unionStates.png" alt="unionStates"></p>
<p>然后又调用initMergeMapList方法获得一个List，这个List中每个元素是一个Map。如下：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/mergeMapList.png" alt="mergeMapList"></p>
<p>Map的key就是其value的delegateStateHandle字段。每个元素表示一个并行实例。</p>
<p>最后进入repartitionUnionState方法，将UNION状态重分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">repartitionUnionState</span><span class="o">(</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">unionState</span><span class="o">,</span>
      <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">mergeMapList</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">mergeMap</span> <span class="o">:</span> <span class="n">mergeMapList</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">:</span>
            <span class="n">unionState</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>

         <span class="k">for</span> <span class="o">(</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span> <span class="n">handleWithMetaInfo</span> <span class="o">:</span> <span class="n">e</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">OperatorStateHandle</span> <span class="n">operatorStateHandle</span> <span class="o">=</span> <span class="n">mergeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">handleWithMetaInfo</span><span class="o">.</span><span class="na">f0</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">operatorStateHandle</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">operatorStateHandle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorStreamStateHandle</span><span class="o">(</span>
                  <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">unionState</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">,</span>
                  <span class="n">handleWithMetaInfo</span><span class="o">.</span><span class="na">f0</span><span class="o">)</span><span class="o">;</span>
               <span class="n">mergeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">handleWithMetaInfo</span><span class="o">.</span><span class="na">f0</span><span class="o">,</span> <span class="n">operatorStateHandle</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">operatorStateHandle</span><span class="o">.</span><span class="na">getStateNameToPartitionOffsets</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">handleWithMetaInfo</span><span class="o">.</span><span class="na">f1</span><span class="o">)</span><span class="o">;</span>
         <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法很简单，就是对两个集合类型的对象做笛卡尔积。直接看最后的结果：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/mergeMapListAfterRepartition.png" alt="mergeMapListAfterRepartition"></p>
<p>之前说过这个List中每个元素表示一个并行实例。现在每个并行实例中都从原来一个元素变为了两个元素。每个并行实例都获得了所有状态的文件元信息。</p>
<p>然后将其中的values取出来，让入另一个List中返回。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mergeMapList</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">mergeMapList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span><span class="o">.</span><span class="na">values</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这样这个列表中就包含了每个并行实例负责的文件元信息。每个并行实例通过其在列表中的索引确定。</p>
<p>回到applyRepartitioner方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">states</span> <span class="o">=</span> <span class="n">applyRepartitioner</span><span class="o">(</span>
   <span class="n">opStateRepartitioner</span><span class="o">,</span>
   <span class="n">chainOpParallelStates</span><span class="o">,</span>
   <span class="n">oldParallelism</span><span class="o">,</span>
   <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

<span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">states</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">subtaskIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">subtaskIndex</span> <span class="o">&lt;</span> <span class="n">states</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">subtaskIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">checkNotNull</span><span class="o">(</span><span class="n">states</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">)</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">,</span> <span class="s">&#34;states.get(subtaskIndex) is null&#34;</span><span class="o">)</span><span class="o">;</span>
   <span class="n">result</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">OperatorInstanceID</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">,</span> <span class="n">operatorID</span><span class="o">)</span><span class="o">,</span> <span class="n">states</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">subtaskIndex</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>就是将这些信息又传入一个Map来存放。key为并行实例的OperatorInstanceID，value为其所负责的文件元信息列表。如下：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/OperatorInstanceIDMap.png" alt="OperatorInstanceIDMap"></p>
<p>最终，就得到了所有新的并行实例与其负责的文件元信息的关系：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/newManagedOperatorStatesComplete.png" alt="newManagedOperatorStatesComplete"></p>
<p>至此分析完了StateAssignmentOperation.assignAttemptState方法中对OperatorState分配的整个流程。KeyedState流程与此类似。</p>
<h3 id="并行度发生改变">并行度发生改变</h3>
<p>当并行度发生改变时，流程一致，只是需要对三种模式都进行重分配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">GroupByStateNameResults</span> <span class="n">nameToStateByMode</span> <span class="o">=</span> <span class="n">groupByStateMode</span><span class="o">(</span><span class="n">previousParallelSubtaskStates</span><span class="o">)</span><span class="o">;</span>

<span class="n">mergeMapList</span> <span class="o">=</span>
   <span class="n">repartition</span><span class="o">(</span><span class="n">nameToStateByMode</span><span class="o">,</span> <span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>先按照Mode将状态分开：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/nameToStateByMode.png" alt="nameToStateByMode"></p>
<p>进入repartition方法对每一种模式进行重分配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">repartition</span><span class="o">(</span>
      <span class="n">GroupByStateNameResults</span> <span class="n">nameToStateByMode</span><span class="o">,</span>
      <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">)</span> <span class="o">{</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">mergeMapList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">newParallelism</span><span class="o">)</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">newParallelism</span><span class="o">;</span> <span class="o">+</span><span class="o">+</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">mergeMapList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="c1">// 对SPLIT_DISTRIBUTE模式进行重分配。
</span><span class="c1"></span>   <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">nameToDistributeState</span> <span class="o">=</span>
         <span class="n">nameToStateByMode</span><span class="o">.</span><span class="na">getByMode</span><span class="o">(</span><span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">SPLIT_DISTRIBUTE</span><span class="o">)</span><span class="o">;</span>

   <span class="n">repartitionSplitState</span><span class="o">(</span><span class="n">nameToDistributeState</span><span class="o">,</span> <span class="n">newParallelism</span><span class="o">,</span> <span class="n">mergeMapList</span><span class="o">)</span><span class="o">;</span>

   <span class="c1">// 对UNION模式进行重分配。
</span><span class="c1"></span>   <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">nameToUnionState</span> <span class="o">=</span>
         <span class="n">nameToStateByMode</span><span class="o">.</span><span class="na">getByMode</span><span class="o">(</span><span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">UNION</span><span class="o">)</span><span class="o">;</span>

   <span class="n">repartitionUnionState</span><span class="o">(</span><span class="n">nameToUnionState</span><span class="o">,</span> <span class="n">mergeMapList</span><span class="o">)</span><span class="o">;</span>

   <span class="c1">// 对BROADCAST模式进行重分配。
</span><span class="c1"></span>   <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">StreamStateHandle</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">nameToBroadcastState</span> <span class="o">=</span>
         <span class="n">nameToStateByMode</span><span class="o">.</span><span class="na">getByMode</span><span class="o">(</span><span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">BROADCAST</span><span class="o">)</span><span class="o">;</span>

   <span class="n">repartitionBroadcastState</span><span class="o">(</span><span class="n">nameToBroadcastState</span><span class="o">,</span> <span class="n">mergeMapList</span><span class="o">)</span><span class="o">;</span>

   <span class="k">return</span> <span class="n">mergeMapList</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到对UNION模式重分配时调用的还是之前的方法。对另两种模式的重分配也是类似的流程，这里不再分析。</p>
<h3 id="将文件元信息发往taskexecutor端">将文件元信息发往TaskExecutor端</h3>
<p>状态重分配结束后，进入到assignTaskStateToExecutionJobVertices方法进行一些设置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">assignTaskStateToExecutionJobVertices</span><span class="o">(</span>
      <span class="n">ExecutionJobVertex</span> <span class="n">executionJobVertex</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">subManagedOperatorState</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">subRawOperatorState</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">subManagedKeyedState</span><span class="o">,</span>
      <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorInstanceID</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">subRawKeyedState</span><span class="o">,</span>
      <span class="kt">int</span> <span class="n">newParallelism</span><span class="o">)</span> <span class="o">{</span>

   <span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="n">operatorIDs</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getOperatorIDs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">subTaskIndex</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span> <span class="n">subTaskIndex</span> <span class="o">&lt;</span> <span class="n">newParallelism</span><span class="o">;</span> <span class="n">subTaskIndex</span><span class="o">+</span><span class="o">+</span><span class="o">)</span> <span class="o">{</span>

      <span class="n">Execution</span> <span class="n">currentExecutionAttempt</span> <span class="o">=</span> <span class="n">executionJobVertex</span><span class="o">.</span><span class="na">getTaskVertices</span><span class="o">(</span><span class="o">)</span><span class="o">[</span><span class="n">subTaskIndex</span><span class="o">]</span>
         <span class="o">.</span><span class="na">getCurrentExecutionAttempt</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

      <span class="n">TaskStateSnapshot</span> <span class="n">taskState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskStateSnapshot</span><span class="o">(</span><span class="n">operatorIDs</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="kt">boolean</span> <span class="n">statelessTask</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

      <span class="k">for</span> <span class="o">(</span><span class="n">OperatorID</span> <span class="n">operatorID</span> <span class="o">:</span> <span class="n">operatorIDs</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">OperatorInstanceID</span> <span class="n">instanceID</span> <span class="o">=</span> <span class="n">OperatorInstanceID</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">subTaskIndex</span><span class="o">,</span> <span class="n">operatorID</span><span class="o">)</span><span class="o">;</span>

         <span class="n">OperatorSubtaskState</span> <span class="n">operatorSubtaskState</span> <span class="o">=</span> <span class="n">operatorSubtaskStateFrom</span><span class="o">(</span>
            <span class="n">instanceID</span><span class="o">,</span>
            <span class="n">subManagedOperatorState</span><span class="o">,</span>
            <span class="n">subRawOperatorState</span><span class="o">,</span>
            <span class="n">subManagedKeyedState</span><span class="o">,</span>
            <span class="n">subRawKeyedState</span><span class="o">)</span><span class="o">;</span>

         <span class="k">if</span> <span class="o">(</span><span class="n">operatorSubtaskState</span><span class="o">.</span><span class="na">hasState</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">statelessTask</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
         <span class="o">}</span>
         <span class="n">taskState</span><span class="o">.</span><span class="na">putSubtaskStateByOperatorID</span><span class="o">(</span><span class="n">operatorID</span><span class="o">,</span> <span class="n">operatorSubtaskState</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">statelessTask</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">JobManagerTaskRestore</span> <span class="n">taskRestore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobManagerTaskRestore</span><span class="o">(</span><span class="n">restoreCheckpointId</span><span class="o">,</span> <span class="n">taskState</span><span class="o">)</span><span class="o">;</span>
         <span class="n">currentExecutionAttempt</span><span class="o">.</span><span class="na">setInitialState</span><span class="o">(</span><span class="n">taskRestore</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法所做的事情，是将每个并行实例负责的文件元信息，封装到每个并行实例的Execution对象中。这个对象可以理解为一个并行实例对应发往Task端的那个对象。并且是按照每个算子ID来维护的。这些信息封装在了taskRestore这个对象中，并设置到了Execution对象的taskRestore字段上。之后调用其deploy方法时，会将这个字段封装到一个TaskDeploymentDescriptor对象中，发往TaskExecutor端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">deploy</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">JobException</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="k">try</span> <span class="o">{</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="kd">final</span> <span class="n">TaskDeploymentDescriptor</span> <span class="n">deployment</span> <span class="o">=</span> <span class="n">TaskDeploymentDescriptorFactory</span>
         <span class="o">.</span><span class="na">fromExecutionVertex</span><span class="o">(</span><span class="n">vertex</span><span class="o">,</span> <span class="n">attemptNumber</span><span class="o">)</span>
         <span class="o">.</span><span class="na">createDeploymentDescriptor</span><span class="o">(</span>
            <span class="n">slot</span><span class="o">.</span><span class="na">getAllocationId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
            <span class="n">slot</span><span class="o">.</span><span class="na">getPhysicalSlotNumber</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
            <span class="n">taskRestore</span><span class="o">,</span>
            <span class="n">producedPartitions</span><span class="o">.</span><span class="na">values</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="n">CompletableFuture</span><span class="o">.</span><span class="na">supplyAsync</span><span class="o">(</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">taskManagerGateway</span><span class="o">.</span><span class="na">submitTask</span><span class="o">(</span><span class="n">deployment</span><span class="o">,</span> <span class="n">rpcTimeout</span><span class="o">)</span><span class="o">,</span> <span class="n">executor</span><span class="o">)</span>
         <span class="o">.</span><span class="na">thenCompose</span><span class="o">(</span><span class="n">Function</span><span class="o">.</span><span class="na">identity</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
         <span class="o">.</span><span class="na">whenCompleteAsync</span><span class="o">(</span>
            <span class="o">(</span><span class="n">ack</span><span class="o">,</span> <span class="n">failure</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="o">{</span>
               
              <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
                
            <span class="o">}</span><span class="o">,</span>
            <span class="n">jobMasterMainThreadExecutor</span><span class="o">)</span><span class="o">;</span>

   <span class="o">}</span>
   <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="taskexecutor端">TaskExecutor端</h2>
<h3 id="tdd对象如何被封装和传递">tdd对象如何被封装和传递</h3>
<p>顺着上面的taskManagerGateway.submitTask方法往下走，就来到了Task端。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Acknowledge</span><span class="o">&gt;</span> <span class="nf">submitTask</span><span class="o">(</span>
      <span class="n">TaskDeploymentDescriptor</span> <span class="n">tdd</span><span class="o">,</span>
      <span class="n">JobMasterId</span> <span class="n">jobMasterId</span><span class="o">,</span>
      <span class="n">Time</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">try</span> <span class="o">{</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="kd">final</span> <span class="n">JobManagerTaskRestore</span> <span class="n">taskRestore</span> <span class="o">=</span> <span class="n">tdd</span><span class="o">.</span><span class="na">getTaskRestore</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

      <span class="kd">final</span> <span class="n">TaskStateManager</span> <span class="n">taskStateManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskStateManagerImpl</span><span class="o">(</span>
         <span class="n">jobId</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getExecutionAttemptId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">localStateStore</span><span class="o">,</span>
         <span class="n">taskRestore</span><span class="o">,</span>
         <span class="n">checkpointResponder</span><span class="o">)</span><span class="o">;</span>

      <span class="n">Task</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Task</span><span class="o">(</span>
         <span class="n">jobInformation</span><span class="o">,</span>
         <span class="n">taskInformation</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getExecutionAttemptId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getAllocationId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getSubtaskIndex</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getAttemptNumber</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getProducedPartitions</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getInputGates</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">tdd</span><span class="o">.</span><span class="na">getTargetSlotNumber</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getMemoryManager</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getIOManager</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getShuffleEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getKvStateService</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getBroadcastVariableManager</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskExecutorServices</span><span class="o">.</span><span class="na">getTaskEventDispatcher</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskStateManager</span><span class="o">,</span>
         <span class="n">taskManagerActions</span><span class="o">,</span>
         <span class="n">inputSplitProvider</span><span class="o">,</span>
         <span class="n">checkpointResponder</span><span class="o">,</span>
         <span class="n">aggregateManager</span><span class="o">,</span>
         <span class="n">blobCacheService</span><span class="o">,</span>
         <span class="n">libraryCache</span><span class="o">,</span>
         <span class="n">fileCache</span><span class="o">,</span>
         <span class="n">taskManagerConfiguration</span><span class="o">,</span>
         <span class="n">taskMetricGroup</span><span class="o">,</span>
         <span class="n">resultPartitionConsumableNotifier</span><span class="o">,</span>
         <span class="n">partitionStateChecker</span><span class="o">,</span>
         <span class="n">getRpcService</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getExecutor</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">TaskSubmissionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">FutureUtils</span><span class="o">.</span><span class="na">completedExceptionally</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>传入的参数tdd就是上面的deployment对象。这里获取了其中的taskRestore对象，将其封装在了TaskStateManager对象中，然后封装进了Task对象中。</p>
<p>在Task的run方法中（即doRun方法），与TaskStateManager对象有关的操作如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">try</span> <span class="o">{</span>
      <span class="n">doRun</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
      <span class="n">terminationFuture</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="n">executionState</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doRun</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
  
   <span class="n">AbstractInvokable</span> <span class="n">invokable</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

   <span class="k">try</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="n">Environment</span> <span class="n">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimeEnvironment</span><span class="o">(</span>
         <span class="n">jobId</span><span class="o">,</span>
         <span class="n">vertexId</span><span class="o">,</span>
         <span class="n">executionId</span><span class="o">,</span>
         <span class="n">executionConfig</span><span class="o">,</span>
         <span class="n">taskInfo</span><span class="o">,</span>
         <span class="n">jobConfiguration</span><span class="o">,</span>
         <span class="n">taskConfiguration</span><span class="o">,</span>
         <span class="n">userCodeClassLoader</span><span class="o">,</span>
         <span class="n">memoryManager</span><span class="o">,</span>
         <span class="n">ioManager</span><span class="o">,</span>
         <span class="n">broadcastVariableManager</span><span class="o">,</span>
         <span class="n">taskStateManager</span><span class="o">,</span>
         <span class="n">aggregateManager</span><span class="o">,</span>
         <span class="n">accumulatorRegistry</span><span class="o">,</span>
         <span class="n">kvStateRegistry</span><span class="o">,</span>
         <span class="n">inputSplitProvider</span><span class="o">,</span>
         <span class="n">distributedCacheEntries</span><span class="o">,</span>
         <span class="n">consumableNotifyingPartitionWriters</span><span class="o">,</span>
         <span class="n">inputGates</span><span class="o">,</span>
         <span class="n">taskEventDispatcher</span><span class="o">,</span>
         <span class="n">checkpointResponder</span><span class="o">,</span>
         <span class="n">taskManagerConfig</span><span class="o">,</span>
         <span class="n">metrics</span><span class="o">,</span>
         <span class="k">this</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="n">invokable</span> <span class="o">=</span> <span class="n">loadAndInstantiateInvokable</span><span class="o">(</span><span class="n">userCodeClassLoader</span><span class="o">,</span> <span class="n">nameOfInvokableClass</span><span class="o">,</span> <span class="n">env</span><span class="o">)</span><span class="o">;</span>

      <span class="k">this</span><span class="o">.</span><span class="na">invokable</span> <span class="o">=</span> <span class="n">invokable</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="n">invokable</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
   <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">t</span><span class="o">)</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
   <span class="k">finally</span> <span class="o">{</span>
      
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>将TaskStateManager封装进了RuntimeEnvironment对象中，又将RuntimeEnvironment对象封装进了invokable中，这个invokable是通过反射构造的StreamTask类的对象，类的名称也是通过tdd对象传过来的。而tdd中的这个信息是从何而来的，会在分析flink生成StreamGraph、JobGraph、ExecutionGraph的文章中提及。</p>
<p>进入到invoke方法中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="kt">boolean</span> <span class="n">disposed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
   <span class="k">try</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="n">init</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">initializeState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
         <span class="n">openAllOperators</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="n">run</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="o">}</span>
   <span class="k">finally</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里面有几个关键步骤，如init、initializeState、openAllOperators、run等。其中init方法是为Task做一些初始化操作。initializerState方法就是用来恢复状态的方法，其中逻辑比较复杂，最终会调用userFunction中的initializerState方法，如FlinkKafkaConsumerBase类中的initializerState方法。openAllOperators方法也会根据不同算子有不同的初始化操作，最终会调用到RichFunction的open方法。run方法就是真正开始处理数据的地方，内部是一个while(true)循环。</p>
<p>因此本文分析的目标就是initializeState方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">initializeState</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="n">StreamOperator</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span><span class="o">[</span><span class="o">]</span> <span class="n">allOperators</span> <span class="o">=</span> <span class="n">operatorChain</span><span class="o">.</span><span class="na">getAllOperators</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="k">for</span> <span class="o">(</span><span class="n">StreamOperator</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">operator</span> <span class="o">:</span> <span class="n">allOperators</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!</span><span class="o">=</span> <span class="n">operator</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">operator</span><span class="o">.</span><span class="na">initializeState</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>StreamOperator接口就是对业务代码中每一个算子的抽象。事实上在业务代码中，每次添加一个算子，内部都会封装成一个StreamOperator实现类。如果这个实现类是AbstractUdfStreamOperator的子类（AbstractUdfStreamOperator是一个抽象类），那么内部就中封装了userFunction，比如map算子中自己实现的MapFunction。</p>
<p>进入到operator.initializeState方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">initializeState</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="kd">final</span> <span class="n">TypeSerializer</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">keySerializer</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="na">getStateKeySerializer</span><span class="o">(</span><span class="n">getUserCodeClassloader</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="kd">final</span> <span class="n">StreamTask</span><span class="o">&lt;</span><span class="o">?</span><span class="o">,</span> <span class="o">?</span><span class="o">&gt;</span> <span class="n">containingTask</span> <span class="o">=</span>
      <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">getContainingTask</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="kd">final</span> <span class="n">CloseableRegistry</span> <span class="n">streamTaskCloseableRegistry</span> <span class="o">=</span>
      <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">containingTask</span><span class="o">.</span><span class="na">getCancelables</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="kd">final</span> <span class="n">StreamTaskStateInitializer</span> <span class="n">streamTaskStateManager</span> <span class="o">=</span>
      <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">containingTask</span><span class="o">.</span><span class="na">createStreamTaskStateInitializer</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="kd">final</span> <span class="n">StreamOperatorStateContext</span> <span class="n">context</span> <span class="o">=</span>
      <span class="n">streamTaskStateManager</span><span class="o">.</span><span class="na">streamOperatorStateContext</span><span class="o">(</span>
         <span class="n">getOperatorID</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">getClass</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="k">this</span><span class="o">,</span>
         <span class="n">keySerializer</span><span class="o">,</span>
         <span class="n">streamTaskCloseableRegistry</span><span class="o">,</span>
         <span class="n">metrics</span><span class="o">)</span><span class="o">;</span>

   <span class="k">this</span><span class="o">.</span><span class="na">operatorStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">operatorStateBackend</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">keyedStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">keyedStateBackend</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">keyedStateBackend</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">keyedStateStore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultKeyedStateStore</span><span class="o">(</span><span class="n">keyedStateBackend</span><span class="o">,</span> <span class="n">getExecutionConfig</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="n">timeServiceManager</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">internalTimerServiceManager</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">keyedStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">rawKeyedStateInputs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">operatorStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">rawOperatorStateInputs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="k">try</span> <span class="o">{</span>
      <span class="n">StateInitializationContext</span> <span class="n">initializationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateInitializationContextImpl</span><span class="o">(</span>
         <span class="n">context</span><span class="o">.</span><span class="na">isRestored</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="c1">// information whether we restore or start for the first time
</span><span class="c1"></span>         <span class="n">operatorStateBackend</span><span class="o">,</span> <span class="c1">// access to operator state backend
</span><span class="c1"></span>         <span class="n">keyedStateStore</span><span class="o">,</span> <span class="c1">// access to keyed state backend
</span><span class="c1"></span>         <span class="n">keyedStateInputs</span><span class="o">,</span> <span class="c1">// access to keyed state stream
</span><span class="c1"></span>         <span class="n">operatorStateInputs</span><span class="o">)</span><span class="o">;</span> <span class="c1">// access to operator state stream
</span><span class="c1"></span>
      <span class="n">initializeState</span><span class="o">(</span><span class="n">initializationContext</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
      <span class="n">closeFromRegistry</span><span class="o">(</span><span class="n">operatorStateInputs</span><span class="o">,</span> <span class="n">streamTaskCloseableRegistry</span><span class="o">)</span><span class="o">;</span>
      <span class="n">closeFromRegistry</span><span class="o">(</span><span class="n">keyedStateInputs</span><span class="o">,</span> <span class="n">streamTaskCloseableRegistry</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先分析开头几行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamTask</span><span class="o">&lt;</span><span class="o">?</span><span class="o">,</span> <span class="o">?</span><span class="o">&gt;</span> <span class="n">containingTask</span> <span class="o">=</span>
   <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">getContainingTask</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">CloseableRegistry</span> <span class="n">streamTaskCloseableRegistry</span> <span class="o">=</span>
   <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">containingTask</span><span class="o">.</span><span class="na">getCancelables</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="kd">final</span> <span class="n">StreamTaskStateInitializer</span> <span class="n">streamTaskStateManager</span> <span class="o">=</span>
   <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">containingTask</span><span class="o">.</span><span class="na">createStreamTaskStateInitializer</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个containingTask就是前面提及的那个StreamTask对象，它的createStreamTaskStateInitializer方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">StreamTaskStateInitializer</span> <span class="nf">createStreamTaskStateInitializer</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">return</span> <span class="k">new</span> <span class="n">StreamTaskStateInitializerImpl</span><span class="o">(</span>
      <span class="n">getEnvironment</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">stateBackend</span><span class="o">,</span>
      <span class="n">timerService</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="nf">StreamTaskStateInitializerImpl</span><span class="o">(</span>
   <span class="n">Environment</span> <span class="n">environment</span><span class="o">,</span>
   <span class="n">StateBackend</span> <span class="n">stateBackend</span><span class="o">,</span>
   <span class="n">ProcessingTimeService</span> <span class="n">processingTimeService</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">this</span><span class="o">.</span><span class="na">environment</span> <span class="o">=</span> <span class="n">environment</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">taskStateManager</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">environment</span><span class="o">.</span><span class="na">getTaskStateManager</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">stateBackend</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">stateBackend</span><span class="o">)</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">processingTimeService</span> <span class="o">=</span> <span class="n">processingTimeService</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，之前env对象中的TaskStateManager字段，传递给了StreamTaskStateInitializerImpl的一个实例。</p>
<h3 id="状态恢复的核心逻辑">状态恢复的核心逻辑</h3>
<p>恢复状态的核心逻辑在AbstractStreamOperator.initializeState方法中的这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamOperatorStateContext</span> <span class="n">context</span> <span class="o">=</span>
   <span class="n">streamTaskStateManager</span><span class="o">.</span><span class="na">streamOperatorStateContext</span><span class="o">(</span>
      <span class="n">getOperatorID</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">getClass</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="k">this</span><span class="o">,</span>
      <span class="n">keySerializer</span><span class="o">,</span>
      <span class="n">streamTaskCloseableRegistry</span><span class="o">,</span>
      <span class="n">metrics</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个context对象中保存了所有状态数据，之后会在每个算子的initializeState方法中恢复到它们自己维护的对象上去。下面分析这个context是如何被构造出来的。</p>
<p>进入streamOperatorStateContext方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">StreamOperatorStateContext</span> <span class="nf">streamOperatorStateContext</span><span class="o">(</span>
   <span class="nd">@Nonnull</span> <span class="n">OperatorID</span> <span class="n">operatorID</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">String</span> <span class="n">operatorClassName</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">KeyContext</span> <span class="n">keyContext</span><span class="o">,</span>
   <span class="nd">@Nullable</span> <span class="n">TypeSerializer</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">keySerializer</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">CloseableRegistry</span> <span class="n">streamTaskCloseableRegistry</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">MetricGroup</span> <span class="n">metricGroup</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="n">TaskInfo</span> <span class="n">taskInfo</span> <span class="o">=</span> <span class="n">environment</span><span class="o">.</span><span class="na">getTaskInfo</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="n">OperatorSubtaskDescriptionText</span> <span class="n">operatorSubtaskDescription</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">OperatorSubtaskDescriptionText</span><span class="o">(</span>
         <span class="n">operatorID</span><span class="o">,</span>
         <span class="n">operatorClassName</span><span class="o">,</span>
         <span class="n">taskInfo</span><span class="o">.</span><span class="na">getIndexOfThisSubtask</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">taskInfo</span><span class="o">.</span><span class="na">getNumberOfParallelSubtasks</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

   <span class="kd">final</span> <span class="n">String</span> <span class="n">operatorIdentifierText</span> <span class="o">=</span> <span class="n">operatorSubtaskDescription</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="kd">final</span> <span class="n">PrioritizedOperatorSubtaskState</span> <span class="n">prioritizedOperatorSubtaskStates</span> <span class="o">=</span>
      <span class="n">taskStateManager</span><span class="o">.</span><span class="na">prioritizedOperatorState</span><span class="o">(</span><span class="n">operatorID</span><span class="o">)</span><span class="o">;</span>

   <span class="n">AbstractKeyedStateBackend</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">keyedStatedBackend</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">OperatorStateBackend</span> <span class="n">operatorStateBackend</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">rawKeyedStateInputs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">rawOperatorStateInputs</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
   <span class="n">InternalTimeServiceManager</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">timeServiceManager</span><span class="o">;</span>

   <span class="k">try</span> <span class="o">{</span>

      <span class="c1">// -------------- Keyed State Backend --------------
</span><span class="c1"></span>      <span class="n">keyedStatedBackend</span> <span class="o">=</span> <span class="n">keyedStatedBackend</span><span class="o">(</span>
         <span class="n">keySerializer</span><span class="o">,</span>
         <span class="n">operatorIdentifierText</span><span class="o">,</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">,</span>
         <span class="n">streamTaskCloseableRegistry</span><span class="o">,</span>
         <span class="n">metricGroup</span><span class="o">)</span><span class="o">;</span>

      <span class="c1">// -------------- Operator State Backend --------------
</span><span class="c1"></span>      <span class="n">operatorStateBackend</span> <span class="o">=</span> <span class="n">operatorStateBackend</span><span class="o">(</span>
         <span class="n">operatorIdentifierText</span><span class="o">,</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">,</span>
         <span class="n">streamTaskCloseableRegistry</span><span class="o">)</span><span class="o">;</span>

      <span class="c1">// -------------- Raw State Streams --------------
</span><span class="c1"></span>      <span class="n">rawKeyedStateInputs</span> <span class="o">=</span> <span class="n">rawKeyedStateInputs</span><span class="o">(</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">.</span><span class="na">getPrioritizedRawKeyedState</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="n">streamTaskCloseableRegistry</span><span class="o">.</span><span class="na">registerCloseable</span><span class="o">(</span><span class="n">rawKeyedStateInputs</span><span class="o">)</span><span class="o">;</span>

      <span class="n">rawOperatorStateInputs</span> <span class="o">=</span> <span class="n">rawOperatorStateInputs</span><span class="o">(</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">.</span><span class="na">getPrioritizedRawOperatorState</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      <span class="n">streamTaskCloseableRegistry</span><span class="o">.</span><span class="na">registerCloseable</span><span class="o">(</span><span class="n">rawOperatorStateInputs</span><span class="o">)</span><span class="o">;</span>

      <span class="c1">// -------------- Internal Timer Service Manager --------------
</span><span class="c1"></span>      <span class="n">timeServiceManager</span> <span class="o">=</span> <span class="n">internalTimeServiceManager</span><span class="o">(</span><span class="n">keyedStatedBackend</span><span class="o">,</span> <span class="n">keyContext</span><span class="o">,</span> <span class="n">rawKeyedStateInputs</span><span class="o">)</span><span class="o">;</span>

      <span class="c1">// -------------- Preparing return value --------------
</span><span class="c1"></span>
      <span class="k">return</span> <span class="k">new</span> <span class="n">StreamOperatorStateContextImpl</span><span class="o">(</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">.</span><span class="na">isRestored</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
         <span class="n">operatorStateBackend</span><span class="o">,</span>
         <span class="n">keyedStatedBackend</span><span class="o">,</span>
         <span class="n">timeServiceManager</span><span class="o">,</span>
         <span class="n">rawOperatorStateInputs</span><span class="o">,</span>
         <span class="n">rawKeyedStateInputs</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这一步中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">PrioritizedOperatorSubtaskState</span> <span class="n">prioritizedOperatorSubtaskStates</span> <span class="o">=</span>
   <span class="n">taskStateManager</span><span class="o">.</span><span class="na">prioritizedOperatorState</span><span class="o">(</span><span class="n">operatorID</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>将taskStateManager中的本算子对应负责的文件元信息获取出来封装到了PrioritizedOperatorSubtaskState对象中。内容如下：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/prioritizedOperatorSubtaskStates.png" alt="prioritizedOperatorSubtaskStates"></p>
<p>接下来就是对每一种状态后端进行恢复，最后封装到StreamOperatorStateContextImpl中。本文仅分析OperatorStateBackend的恢复流程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="n">OperatorStateBackend</span> <span class="nf">operatorStateBackend</span><span class="o">(</span>
   <span class="n">String</span> <span class="n">operatorIdentifierText</span><span class="o">,</span>
   <span class="n">PrioritizedOperatorSubtaskState</span> <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">,</span>
   <span class="n">CloseableRegistry</span> <span class="n">backendCloseableRegistry</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
   <span class="n">BackendRestorerProcedure</span><span class="o">&lt;</span><span class="n">OperatorStateBackend</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">backendRestorer</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">BackendRestorerProcedure</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span>
         <span class="o">(</span><span class="n">stateHandles</span><span class="o">)</span> <span class="o">-</span><span class="o">&gt;</span> <span class="n">stateBackend</span><span class="o">.</span><span class="na">createOperatorStateBackend</span><span class="o">(</span>
            <span class="n">environment</span><span class="o">,</span>
            <span class="n">operatorIdentifierText</span><span class="o">,</span>
            <span class="n">stateHandles</span><span class="o">,</span>
            <span class="n">cancelStreamRegistryForRestore</span><span class="o">)</span><span class="o">,</span>
         <span class="n">backendCloseableRegistry</span><span class="o">,</span>
         <span class="n">logDescription</span><span class="o">)</span><span class="o">;</span>

   <span class="k">try</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">backendRestorer</span><span class="o">.</span><span class="na">createAndRestore</span><span class="o">(</span>
         <span class="n">prioritizedOperatorSubtaskStates</span><span class="o">.</span><span class="na">getPrioritizedManagedOperatorState</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意到，BackendRestorerProcedure构造方法的第一个参数是一个Lambda表达式（实际上是一个FunctionWithException接口）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">FunctionWithException</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">R</span><span class="o">,</span> <span class="n">E</span> <span class="kd">extends</span> <span class="n">Throwable</span><span class="o">&gt;</span> <span class="o">{</span>

   <span class="cm">/**
</span><span class="cm">    * Calls this function.
</span><span class="cm">    *
</span><span class="cm">    * @param value The argument to the function.
</span><span class="cm">    * @return The result of thus supplier.
</span><span class="cm">    * @throws E This function may throw an exception.
</span><span class="cm">    */</span>
   <span class="n">R</span> <span class="nf">apply</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">E</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>T对应Lambda表达式的输入类型，R对应其输出类型，E对应其抛出的异常类型。</p>
<p>构造方法为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">BackendRestorerProcedure</span><span class="o">(</span>
   <span class="nd">@Nonnull</span> <span class="n">FunctionWithException</span><span class="o">&lt;</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">Exception</span><span class="o">&gt;</span> <span class="n">instanceSupplier</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">CloseableRegistry</span> <span class="n">backendCloseableRegistry</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">String</span> <span class="n">logDescription</span><span class="o">)</span> <span class="o">{</span>

   <span class="k">this</span><span class="o">.</span><span class="na">instanceSupplier</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">instanceSupplier</span><span class="o">)</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">backendCloseableRegistry</span> <span class="o">=</span> <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">backendCloseableRegistry</span><span class="o">)</span><span class="o">;</span>
   <span class="k">this</span><span class="o">.</span><span class="na">logDescription</span> <span class="o">=</span> <span class="n">logDescription</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从方法签名可以看出，它要求Lambda表达式输入为一个集合，而集合中的元素必须为S，其类型有所限制：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BackendRestorerProcedure</span><span class="o">&lt;</span>
   <span class="n">T</span> <span class="kd">extends</span> <span class="n">Closeable</span> <span class="o">&amp;</span> <span class="n">Disposable</span><span class="o">,</span>
   <span class="n">S</span> <span class="kd">extends</span> <span class="n">StateObject</span><span class="o">&gt;</span> <span class="o">{</span>

   <span class="cm">/** Logger for this class. */</span>
   <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">Logger</span> <span class="n">LOG</span> <span class="o">=</span> <span class="n">LoggerFactory</span><span class="o">.</span><span class="na">getLogger</span><span class="o">(</span><span class="n">BackendRestorerProcedure</span><span class="o">.</span><span class="na">class</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>输出为T，类型也由上面限制。抛出的异常为Exception。可以看到Lambda表达式中那个方法抛出的异常：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">OperatorStateBackend</span> <span class="nf">createOperatorStateBackend</span><span class="o">(</span>
   <span class="n">Environment</span> <span class="n">env</span><span class="o">,</span>
   <span class="n">String</span> <span class="n">operatorIdentifier</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">stateHandles</span><span class="o">,</span>
   <span class="n">CloseableRegistry</span> <span class="n">cancelStreamRegistry</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个Lambda表达式作为BackendRestorerProcedure的一个字段，之后会在BackendRestorerProcedure的某个方法中调用其apply方法。</p>
<p>接下来进入到backendRestorer.createAndRestore方法，其参数就是从prioritizedOperatorSubtaskStates取出的ManagedOperatorState。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">T</span> <span class="nf">createAndRestore</span><span class="o">(</span><span class="nd">@Nonnull</span> <span class="n">List</span><span class="o">&lt;</span><span class="o">?</span> <span class="kd">extends</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">restoreOptions</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="kt">int</span> <span class="n">alternativeIdx</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="k">while</span> <span class="o">(</span><span class="n">alternativeIdx</span> <span class="o">&lt;</span> <span class="n">restoreOptions</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>

      <span class="n">Collection</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">restoreState</span> <span class="o">=</span> <span class="n">restoreOptions</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">alternativeIdx</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
      <span class="k">try</span> <span class="o">{</span>
         <span class="k">return</span> <span class="n">attemptCreateAndRestore</span><span class="o">(</span><span class="n">restoreState</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
          
      <span class="o">}</span>
   <span class="o">}</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在之前的封装过程中我们知道restoreOptions是一个SingletonList，所以可以认为restoreState对象中包含了这个并行实例中这个算子负责的所有文件元信息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">T</span> <span class="nf">attemptCreateAndRestore</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">restoreState</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="kd">final</span> <span class="n">T</span> <span class="n">backendInstance</span> <span class="o">=</span> <span class="n">instanceSupplier</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">restoreState</span><span class="o">)</span><span class="o">;</span>

   <span class="k">try</span> <span class="o">{</span>
      <span class="n">backendCloseableRegistry</span><span class="o">.</span><span class="na">registerCloseable</span><span class="o">(</span><span class="n">backendInstance</span><span class="o">)</span><span class="o">;</span>
      <span class="k">return</span> <span class="n">backendInstance</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这里调用了apply方法。输入就是restoreState对象，对这个对象调用stateBackend.createOperatorStateBackend方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">OperatorStateBackend</span> <span class="nf">createOperatorStateBackend</span><span class="o">(</span>
   <span class="n">Environment</span> <span class="n">env</span><span class="o">,</span>
   <span class="n">String</span> <span class="n">operatorIdentifier</span><span class="o">,</span>
   <span class="nd">@Nonnull</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">stateHandles</span><span class="o">,</span>
   <span class="n">CloseableRegistry</span> <span class="n">cancelStreamRegistry</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">BackendBuildingException</span> <span class="o">{</span>

   <span class="k">return</span> <span class="k">new</span> <span class="n">DefaultOperatorStateBackendBuilder</span><span class="o">(</span>
      <span class="n">env</span><span class="o">.</span><span class="na">getUserClassLoader</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">env</span><span class="o">.</span><span class="na">getExecutionConfig</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">isUsingAsynchronousSnapshots</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">stateHandles</span><span class="o">,</span>
      <span class="n">cancelStreamRegistry</span><span class="o">)</span><span class="o">.</span><span class="na">build</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>对于不同的状态后端，有不同的实现，本文分析FsStateBackend。</p>
<p>首先将文件元信息封装到了DefaultOperatorStateBackendBuilder的restoreStateHandles字段，然后调用build方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">DefaultOperatorStateBackend</span> <span class="nf">build</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">BackendBuildingException</span> <span class="o">{</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">registeredOperatorStates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BackendWritableBroadcastState</span><span class="o">&lt;</span><span class="o">?</span><span class="o">,</span> <span class="o">?</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">registeredBroadcastStates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="n">CloseableRegistry</span> <span class="n">cancelStreamRegistryForBackend</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CloseableRegistry</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="n">AbstractSnapshotStrategy</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="n">snapshotStrategy</span> <span class="o">=</span>
      <span class="k">new</span> <span class="n">DefaultOperatorStateBackendSnapshotStrategy</span><span class="o">(</span>
         <span class="n">userClassloader</span><span class="o">,</span>
         <span class="n">asynchronousSnapshots</span><span class="o">,</span>
         <span class="n">registeredOperatorStates</span><span class="o">,</span>
         <span class="n">registeredBroadcastStates</span><span class="o">,</span>
         <span class="n">cancelStreamRegistryForBackend</span><span class="o">)</span><span class="o">;</span>
   <span class="n">OperatorStateRestoreOperation</span> <span class="n">restoreOperation</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorStateRestoreOperation</span><span class="o">(</span>
      <span class="n">cancelStreamRegistry</span><span class="o">,</span>
      <span class="n">userClassloader</span><span class="o">,</span>
      <span class="n">registeredOperatorStates</span><span class="o">,</span>
      <span class="n">registeredBroadcastStates</span><span class="o">,</span>
      <span class="n">restoreStateHandles</span>
   <span class="o">)</span><span class="o">;</span>
   <span class="k">try</span> <span class="o">{</span>
      <span class="n">restoreOperation</span><span class="o">.</span><span class="na">restore</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">IOUtils</span><span class="o">.</span><span class="na">closeQuietly</span><span class="o">(</span><span class="n">cancelStreamRegistryForBackend</span><span class="o">)</span><span class="o">;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="n">BackendBuildingException</span><span class="o">(</span><span class="s">&#34;Failed when trying to restore operator state backend&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="k">new</span> <span class="n">DefaultOperatorStateBackend</span><span class="o">(</span>
      <span class="n">executionConfig</span><span class="o">,</span>
      <span class="n">cancelStreamRegistryForBackend</span><span class="o">,</span>
      <span class="n">registeredOperatorStates</span><span class="o">,</span>
      <span class="n">registeredBroadcastStates</span><span class="o">,</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">snapshotStrategy</span>
   <span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法先创建了两个Map，registeredOperatorStates和registeredBroadcastStates，将其封装在了snapshotStrategy中，最后将snapshotStrategy封装在了DefaultOperatorStateBackend对象中返回。同时，又将registeredOperatorStates和registeredBroadcastStates封装在了OperatorStateRestoreOperation对象中，调用了restoreOperation.restore方法。因此基本可以确定，restoreOperation.restore方法就是恢复数据并填充到这两个Map中。下面的代码忽略了BroadcastState的恢复流程（与OperatorState类似），仅分析OperatorState的恢复。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Void</span> <span class="nf">restore</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
   <span class="k">if</span> <span class="o">(</span><span class="n">stateHandles</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
   <span class="o">}</span>

   <span class="k">for</span> <span class="o">(</span><span class="n">OperatorStateHandle</span> <span class="n">stateHandle</span> <span class="o">:</span> <span class="n">stateHandles</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">stateHandle</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">continue</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// 1.构建输入流。
</span><span class="c1"></span>      <span class="n">FSDataInputStream</span> <span class="n">in</span> <span class="o">=</span> <span class="n">stateHandle</span><span class="o">.</span><span class="na">openInputStream</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
     
     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

      <span class="k">try</span> <span class="o">{</span>
        
        <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
          
         <span class="c1">// 2.读取状态元信息（即序列化器的信息）。
</span><span class="c1"></span>         <span class="n">OperatorBackendSerializationProxy</span> <span class="n">backendSerializationProxy</span> <span class="o">=</span>
            <span class="k">new</span> <span class="n">OperatorBackendSerializationProxy</span><span class="o">(</span><span class="n">userClassloader</span><span class="o">)</span><span class="o">;</span>
         <span class="n">backendSerializationProxy</span><span class="o">.</span><span class="na">read</span><span class="o">(</span><span class="k">new</span> <span class="n">DataInputViewStreamWrapper</span><span class="o">(</span><span class="n">in</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
         <span class="n">List</span><span class="o">&lt;</span><span class="n">StateMetaInfoSnapshot</span><span class="o">&gt;</span> <span class="n">restoredOperatorMetaInfoSnapshots</span> <span class="o">=</span>
            <span class="n">backendSerializationProxy</span><span class="o">.</span><span class="na">getOperatorStateMetaInfoSnapshots</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

         <span class="c1">// 3.将状态注册到registeredOperatorStates中。
</span><span class="c1"></span>         <span class="k">for</span> <span class="o">(</span><span class="n">StateMetaInfoSnapshot</span> <span class="n">restoredSnapshot</span> <span class="o">:</span> <span class="n">restoredOperatorMetaInfoSnapshots</span><span class="o">)</span> <span class="o">{</span>

            <span class="kd">final</span> <span class="n">RegisteredOperatorStateBackendMetaInfo</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">restoredMetaInfo</span> <span class="o">=</span>
               <span class="k">new</span> <span class="n">RegisteredOperatorStateBackendMetaInfo</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">restoredSnapshot</span><span class="o">)</span><span class="o">;</span>
           
           <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

            <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">listState</span> <span class="o">=</span> <span class="n">registeredOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">restoredSnapshot</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">=</span><span class="o">=</span> <span class="n">listState</span><span class="o">)</span> <span class="o">{</span>
               <span class="n">listState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">restoredMetaInfo</span><span class="o">)</span><span class="o">;</span>
               <span class="n">registeredOperatorStates</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">listState</span><span class="o">.</span><span class="na">getStateMetaInfo</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getName</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">listState</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
              
              <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
                
            <span class="o">}</span>
         <span class="o">}</span>
        
        <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

         <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span> <span class="n">nameToOffsets</span> <span class="o">:</span>
            <span class="n">stateHandle</span><span class="o">.</span><span class="na">getStateNameToPartitionOffsets</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">final</span> <span class="n">String</span> <span class="n">stateName</span> <span class="o">=</span> <span class="n">nameToOffsets</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">listStateForName</span> <span class="o">=</span> <span class="n">registeredOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">stateName</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">listStateForName</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
              
              <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
                
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
               <span class="c1">// 4.从输入流根据每个状态数据在文件中的位置将状态数据反序列化到内存。
</span><span class="c1"></span>               <span class="n">deserializeOperatorStateValues</span><span class="o">(</span><span class="n">listStateForName</span><span class="o">,</span> <span class="n">in</span><span class="o">,</span> <span class="n">nameToOffsets</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
         <span class="o">}</span>

      <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        
        <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
          
      <span class="o">}</span>
   <span class="o">}</span>
   <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再次观察stateHandles对象中的内容：</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/stateHandles.png" alt="stateHandles"></p>
<p>这是一个集合，其中每个元素可以理解为要读取的一个文件。这里只有一个元素。回忆之前的内容，如果一个状态为UNION，并行大于1，那么恢复时每个并行实例就需要去其他文件中取数据，这时stateHandles中就会有多个元素。restore对stateHandles进行遍历，可以理解为每遍历一次，就是去一个不同的文件中取数据。</p>
<p>因此，每次循环的第一步，就是构建输入流。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">FSDataInputStream</span> <span class="nf">openInputStream</span><span class="o">(</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">delegateStateHandle</span><span class="o">.</span><span class="na">openInputStream</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在写入checkpoint数据时，首先是写入序列化器的信息，即状态元信息，这里读取时也是先读取这部分信息，即上面注释的第二步。读取过程就是写入过程的逆过程，本文不分析其中的细节，仅仅看读取完后，backendSerializationProxy对象中包含的信息。</p>
<p><img src="/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/Checkpoint%E7%8A%B6%E6%80%81%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B/backendSerializationProxy.png" alt="backendSerializationProxy"></p>
<p>包含了每个状态的序列化信息。如果是Tuple2这种嵌套的数据类型，它也包含了其中每个元素的序列化信息。</p>
<p>接下来分析第三步。registeredOperatorStates维护了所有的OperatorState状态的数据。在每个算子的initializeState方法中，初始化状态数据时就是通过getListState等方法，经过几层调用后到registeredOperatorStates中根据状态名称获取状态数据。第三步就是先构造一个State对象，将状态注册到registeredOperatorStates中。下面第四步就是反序列化状态数据文件，将数据填充进这个State对象。</p>
<p>进入第四步的deserializeOperatorStateValues方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="nf">deserializeOperatorStateValues</span><span class="o">(</span>
   <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">stateListForName</span><span class="o">,</span>
   <span class="n">FSDataInputStream</span> <span class="n">in</span><span class="o">,</span>
   <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">StateMetaInfo</span> <span class="n">metaInfo</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>

   <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!</span><span class="o">=</span> <span class="n">metaInfo</span><span class="o">)</span> <span class="o">{</span>
      <span class="kt">long</span><span class="o">[</span><span class="o">]</span> <span class="n">offsets</span> <span class="o">=</span> <span class="n">metaInfo</span><span class="o">.</span><span class="na">getOffsets</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="o">!</span><span class="o">=</span> <span class="n">offsets</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">DataInputView</span> <span class="n">div</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataInputViewStreamWrapper</span><span class="o">(</span><span class="n">in</span><span class="o">)</span><span class="o">;</span>
         <span class="n">TypeSerializer</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">serializer</span> <span class="o">=</span> <span class="n">stateListForName</span><span class="o">.</span><span class="na">getStateMetaInfo</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getPartitionStateSerializer</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
         <span class="k">for</span> <span class="o">(</span><span class="kt">long</span> <span class="n">offset</span> <span class="o">:</span> <span class="n">offsets</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">in</span><span class="o">.</span><span class="na">seek</span><span class="o">(</span><span class="n">offset</span><span class="o">)</span><span class="o">;</span>
            <span class="n">stateListForName</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">serializer</span><span class="o">.</span><span class="na">deserialize</span><span class="o">(</span><span class="n">div</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
         <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法比较容易理解，就是获取序列化器，遍历每一个状态数据的位置，依次反序列化，将数据放入State对象中。这里的add方法就是将数据放入PartitionableListState对象中的internalList中。每个序列化器都有不同的实现，本文不分析序列化/反序列化的细节。</p>
<p>至此，每个并行实例都将自己负责的数据加载进了自身的状态后端。回到外层的AbstractStreamOperator.initializeState方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">final</span> <span class="n">StreamOperatorStateContext</span> <span class="n">context</span> <span class="o">=</span>
   <span class="n">streamTaskStateManager</span><span class="o">.</span><span class="na">streamOperatorStateContext</span><span class="o">(</span>
      <span class="n">getOperatorID</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="n">getClass</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">getSimpleName</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
      <span class="k">this</span><span class="o">,</span>
      <span class="n">keySerializer</span><span class="o">,</span>
      <span class="n">streamTaskCloseableRegistry</span><span class="o">,</span>
      <span class="n">metrics</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>此时返回的context就包含了所有从文件中读取出来的状态数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">this</span><span class="o">.</span><span class="na">operatorStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">operatorStateBackend</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="k">this</span><span class="o">.</span><span class="na">keyedStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">keyedStateBackend</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="k">if</span> <span class="o">(</span><span class="n">keyedStateBackend</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
   <span class="k">this</span><span class="o">.</span><span class="na">keyedStateStore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultKeyedStateStore</span><span class="o">(</span><span class="n">keyedStateBackend</span><span class="o">,</span> <span class="n">getExecutionConfig</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">timeServiceManager</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">internalTimerServiceManager</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">keyedStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">rawKeyedStateInputs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="n">operatorStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">rawOperatorStateInputs</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

<span class="k">try</span> <span class="o">{</span>
   <span class="n">StateInitializationContext</span> <span class="n">initializationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateInitializationContextImpl</span><span class="o">(</span>
      <span class="n">context</span><span class="o">.</span><span class="na">isRestored</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="c1">// information whether we restore or start for the first time
</span><span class="c1"></span>      <span class="n">operatorStateBackend</span><span class="o">,</span> <span class="c1">// access to operator state backend
</span><span class="c1"></span>      <span class="n">keyedStateStore</span><span class="o">,</span> <span class="c1">// access to keyed state backend
</span><span class="c1"></span>      <span class="n">keyedStateInputs</span><span class="o">,</span> <span class="c1">// access to keyed state stream
</span><span class="c1"></span>      <span class="n">operatorStateInputs</span><span class="o">)</span><span class="o">;</span> <span class="c1">// access to operator state stream
</span><span class="c1"></span>
   <span class="n">initializeState</span><span class="o">(</span><span class="n">initializationContext</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>经过简单的封装，变为initializationContext对象，调用initializeState(initializationContext)方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">initializeState</span><span class="o">(</span><span class="n">StateInitializationContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
   <span class="kd">super</span><span class="o">.</span><span class="na">initializeState</span><span class="o">(</span><span class="n">context</span><span class="o">)</span><span class="o">;</span>
   <span class="n">StreamingFunctionUtils</span><span class="o">.</span><span class="na">restoreFunctionState</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">userFunction</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">restoreFunctionState</span><span class="o">(</span>
      <span class="n">StateInitializationContext</span> <span class="n">context</span><span class="o">,</span>
      <span class="n">Function</span> <span class="n">userFunction</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="n">Preconditions</span><span class="o">.</span><span class="na">checkNotNull</span><span class="o">(</span><span class="n">context</span><span class="o">)</span><span class="o">;</span>

   <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>

      <span class="k">if</span> <span class="o">(</span><span class="n">tryRestoreFunction</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">userFunction</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
         <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>

      <span class="c1">// inspect if the user function is wrapped, then unwrap and try again if we can restore the inner function
</span><span class="c1"></span>      <span class="k">if</span> <span class="o">(</span><span class="n">userFunction</span> <span class="k">instanceof</span> <span class="n">WrappingFunction</span><span class="o">)</span> <span class="o">{</span>
         <span class="n">userFunction</span> <span class="o">=</span> <span class="o">(</span><span class="o">(</span><span class="n">WrappingFunction</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span><span class="o">)</span> <span class="n">userFunction</span><span class="o">)</span><span class="o">.</span><span class="na">getWrappedFunction</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
         <span class="k">break</span><span class="o">;</span>
      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">}</span>


<span class="kd">private</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">tryRestoreFunction</span><span class="o">(</span>
      <span class="n">StateInitializationContext</span> <span class="n">context</span><span class="o">,</span>
      <span class="n">Function</span> <span class="n">userFunction</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="k">if</span> <span class="o">(</span><span class="n">userFunction</span> <span class="k">instanceof</span> <span class="n">CheckpointedFunction</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">(</span><span class="o">(</span><span class="n">CheckpointedFunction</span><span class="o">)</span> <span class="n">userFunction</span><span class="o">)</span><span class="o">.</span><span class="na">initializeState</span><span class="o">(</span><span class="n">context</span><span class="o">)</span><span class="o">;</span>

      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
   <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>最终调用到了userFunction.initializeState方法。</p>
<p>以FlinkKafkaConsumerBase为例，调用到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">initializeState</span><span class="o">(</span><span class="n">FunctionInitializationContext</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>

   <span class="n">OperatorStateStore</span> <span class="n">stateStore</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="na">getOperatorStateStore</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

   <span class="n">ListState</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">KafkaTopicPartition</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">oldRoundRobinListState</span> <span class="o">=</span>
      <span class="n">stateStore</span><span class="o">.</span><span class="na">getSerializableListState</span><span class="o">(</span><span class="n">DefaultOperatorStateBackend</span><span class="o">.</span><span class="na">DEFAULT_OPERATOR_STATE_NAME</span><span class="o">)</span><span class="o">;</span>

   <span class="k">this</span><span class="o">.</span><span class="na">unionOffsetStates</span> <span class="o">=</span> <span class="n">stateStore</span><span class="o">.</span><span class="na">getUnionListState</span><span class="o">(</span><span class="k">new</span> <span class="n">ListStateDescriptor</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span>
         <span class="n">OFFSETS_STATE_NAME</span><span class="o">,</span>
         <span class="n">TypeInformation</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">TypeHint</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">KafkaTopicPartition</span><span class="o">,</span> <span class="n">Long</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span><span class="o">}</span><span class="o">)</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个unionOffsetStates就是kafka的offset状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">ListState</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="nf">getUnionListState</span><span class="o">(</span><span class="n">ListStateDescriptor</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">stateDescriptor</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
   <span class="k">return</span> <span class="n">getListState</span><span class="o">(</span><span class="n">stateDescriptor</span><span class="o">,</span> <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">Mode</span><span class="o">.</span><span class="na">UNION</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>


<span class="kd">private</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">ListState</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="nf">getListState</span><span class="o">(</span>
      <span class="n">ListStateDescriptor</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">stateDescriptor</span><span class="o">,</span>
      <span class="n">OperatorStateHandle</span><span class="o">.</span><span class="na">Mode</span> <span class="n">mode</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">StateMigrationException</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

   <span class="nd">@SuppressWarnings</span><span class="o">(</span><span class="s">&#34;unchecked&#34;</span><span class="o">)</span>
   <span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">partitionableListState</span> <span class="o">=</span> <span class="o">(</span><span class="n">PartitionableListState</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="o">)</span> <span class="n">registeredOperatorStates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">)</span><span class="o">;</span>

     <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
       
   <span class="k">return</span> <span class="n">partitionableListState</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，就是从registeredOperatorStates中取到了数据。</p>
<h2 id="总结">总结</h2>
<p>状态恢复就是状态写入的逆过程，先在JobManager端读取_metadata文件中的文件元信息，然后在Task端根据文件元信息读取状态数据文件，对每个并行实例进行恢复。</p>
<p>在JobManager端有一个关键步骤，就是将文件元信息分配给每个并行实例。这样每个并行实例才知道自己应该去哪个文件取状态数据。重分配的过程中涉及到了并行度、最大并行度发生变化的情况，文件元数据会根据并行度的变化以及状态本身的模式（UNION、SPLIT_DISTRIBUTE、BROADCAST）按照规则进行重分配。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Weizhe Huang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-20
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/%E6%B7%B1%E5%85%A5flink%E6%BA%90%E7%A0%81-%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%B8%8E%E6%9C%80%E5%A4%A7%E5%B9%B6%E8%A1%8C%E5%BA%A6/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">深入Flink源码 - 并行度与最大并行度</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/flink/%E6%B7%B1%E5%85%A5flink%E6%BA%90%E7%A0%81-checkpoint%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B/">
            <span class="next-text nav-default">深入Flink源码 - Checkpoint文件的写入流程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Weizhe Huang</span>
  </span>
</div>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })
</script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>

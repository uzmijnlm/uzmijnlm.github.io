<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>深入Kafka源码 - Consumer端接收数据全流程 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Weizhe Huang" /><meta name="description" content="一段比较简单的业务代码通常包含下面4步： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { ...... // 1.构造KafkaConsumer对象" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.64.0 with theme even" />


<link rel="canonical" href="http://localhost:1313/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/%E6%B7%B1%E5%85%A5kafka%E6%BA%90%E7%A0%81-consumer%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.c2a46f00.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="深入Kafka源码 - Consumer端接收数据全流程" />
<meta property="og:description" content="一段比较简单的业务代码通常包含下面4步： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { ...... // 1.构造KafkaConsumer对象" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/%E6%B7%B1%E5%85%A5kafka%E6%BA%90%E7%A0%81-consumer%E7%AB%AF%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/" />
<meta property="article:published_time" content="2020-03-31T15:11:40+08:00" />
<meta property="article:modified_time" content="2020-03-31T15:11:40+08:00" />
<meta itemprop="name" content="深入Kafka源码 - Consumer端接收数据全流程">
<meta itemprop="description" content="一段比较简单的业务代码通常包含下面4步： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { ...... // 1.构造KafkaConsumer对象">
<meta itemprop="datePublished" content="2020-03-31T15:11:40&#43;08:00" />
<meta itemprop="dateModified" content="2020-03-31T15:11:40&#43;08:00" />
<meta itemprop="wordCount" content="12189">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入Kafka源码 - Consumer端接收数据全流程"/>
<meta name="twitter:description" content="一段比较简单的业务代码通常包含下面4步： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public static void main(String[] args) { ...... // 1.构造KafkaConsumer对象"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">深入Kafka源码 - Consumer端接收数据全流程</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-03-31 </span>
        <div class="post-category">
            <a href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"> 大数据 </a>
            <a href="/categories/kafka/"> kafka </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#kafkaconsumer构造方法">KafkaConsumer构造方法</a></li>
    <li><a href="#subscriptionstate的作用">SubscriptionState的作用</a></li>
    <li><a href="#kafkaconsumer的poll方法">KafkaConsumer的poll方法</a>
      <ul>
        <li><a href="#consumercoordinator">ConsumerCoordinator</a></li>
        <li><a href="#fetcher">Fetcher</a></li>
        <li><a href="#poll方法中的if分支">poll方法中的if分支</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>一段比较简单的业务代码通常包含下面4步：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[</span><span class="o">]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
  
    <span class="c1">// 1.构造KafkaConsumer对象。
</span><span class="c1"></span>    <span class="n">KafkaConsumer</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">consumer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">KafkaConsumer</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">props</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 2.订阅topic。
</span><span class="c1"></span>    <span class="n">consumer</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&#34;test1&#34;</span><span class="o">,</span> <span class="s">&#34;test2&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 3.从服务端拉取消息。
</span><span class="c1"></span>            <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">consumer</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">100</span><span class="o">)</span><span class="o">;</span>
            <span class="c1">// 4.消费消息。
</span><span class="c1"></span>            <span class="k">for</span> <span class="o">(</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">record</span><span class="o">:</span> <span class="n">records</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">&#34;offset = %d, key = %s, value = %s\n&#34;</span><span class="o">,</span>
                        <span class="n">record</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">record</span><span class="o">.</span><span class="na">key</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">record</span><span class="o">.</span><span class="na">value</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">consumer</span><span class="o">.</span><span class="na">close</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="c1">// 关闭 Consumer
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>复杂一些的处理，比如Flink与Kafka集成的FlinkKafkaConsumer，分析下来其实也是这么4步，只不过封装较多而已。</p>
<p>本文将将对这4个步骤进行详细分析。</p>
<h2 id="kafkaconsumer构造方法">KafkaConsumer构造方法</h2>
<p>Consumer段重要字段有：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">clientId</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">ConsumerCoordinator</span> <span class="n">coordinator</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Deserializer</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="n">keyDeserializer</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Deserializer</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">valueDeserializer</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Fetcher</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">fetcher</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">ConsumerInterceptors</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">interceptors</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">ConsumerNetworkClient</span> <span class="n">client</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">SubscriptionState</span> <span class="n">subscriptions</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Metadata</span> <span class="n">metadata</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>clientId、metadata与Producer端完全一样。keyDeserializer和valueDeserializer对应Producer端的keySerializer和valueSerializer。interceptors与Producer端的interceptors不是同一个类，但作用和用法类似，就是收到数据后进行过滤。因此只需要分析这几个字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">final</span> <span class="n">ConsumerNetworkClient</span> <span class="n">client</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">SubscriptionState</span> <span class="n">subscriptions</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">ConsumerCoordinator</span> <span class="n">coordinator</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Fetcher</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">fetcher</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>其中client初始化过程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">NetworkClient</span> <span class="n">netClient</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NetworkClient</span><span class="o">(</span>
        <span class="k">new</span> <span class="n">Selector</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">CONNECTIONS_MAX_IDLE_MS_CONFIG</span><span class="o">)</span><span class="o">,</span> <span class="n">metrics</span><span class="o">,</span> <span class="n">time</span><span class="o">,</span> <span class="n">metricGrpPrefix</span><span class="o">,</span> <span class="n">channelBuilder</span><span class="o">)</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">metadata</span><span class="o">,</span>
        <span class="n">clientId</span><span class="o">,</span>
        <span class="n">100</span><span class="o">,</span> <span class="c1">// a fixed large enough value will suffice
</span><span class="c1"></span>        <span class="n">config</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">RECONNECT_BACKOFF_MS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">SEND_BUFFER_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">RECEIVE_BUFFER_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">REQUEST_TIMEOUT_MS_CONFIG</span><span class="o">)</span><span class="o">,</span> <span class="n">time</span><span class="o">)</span><span class="o">;</span>
<span class="k">this</span><span class="o">.</span><span class="na">client</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConsumerNetworkClient</span><span class="o">(</span><span class="n">netClient</span><span class="o">,</span> <span class="n">metadata</span><span class="o">,</span> <span class="n">time</span><span class="o">,</span> <span class="n">retryBackoffMs</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">REQUEST_TIMEOUT_MS_CONFIG</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>先是实例化一个NetworkClient对象，其中封装了一个Selector对象，这是KSelector。在Producer端的KafkaProducer构造方法中，也是实例化了一个NetworkClient对象，然后将其封装在了Sender中。NetworkClient负责网络通信，这里也是同样的作用，只是将其封装在了ConsumerNetworkClient中。可以推测，之后是通过这个对象进行网络通信相关操作。</p>
<p>subscriptions字段初始化过程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubscriptionState</span><span class="o">(</span><span class="n">offsetResetStrategy</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>传入的参数表示默认的offset重置策略。这个字段的作用接下来会详细分析。</p>
<p>coordinator字段和fetcher字段初始化过程如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">this</span><span class="o">.</span><span class="na">coordinator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConsumerCoordinator</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">client</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">GROUP_ID_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">SESSION_TIMEOUT_MS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">HEARTBEAT_INTERVAL_MS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">assignors</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">metadata</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">,</span>
        <span class="n">metrics</span><span class="o">,</span>
        <span class="n">metricGrpPrefix</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">time</span><span class="o">,</span>
        <span class="n">retryBackoffMs</span><span class="o">,</span>
        <span class="k">new</span> <span class="n">ConsumerCoordinator</span><span class="o">.</span><span class="na">DefaultOffsetCommitCallback</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">ENABLE_AUTO_COMMIT_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">AUTO_COMMIT_INTERVAL_MS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">interceptors</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">EXCLUDE_INTERNAL_TOPICS_CONFIG</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>


<span class="k">this</span><span class="o">.</span><span class="na">fetcher</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Fetcher</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">client</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">FETCH_MIN_BYTES_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">FETCH_MAX_WAIT_MS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">MAX_PARTITION_FETCH_BYTES_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">MAX_POLL_RECORDS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="n">config</span><span class="o">.</span><span class="na">getBoolean</span><span class="o">(</span><span class="n">ConsumerConfig</span><span class="o">.</span><span class="na">CHECK_CRCS_CONFIG</span><span class="o">)</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">keyDeserializer</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">valueDeserializer</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">metadata</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">,</span>
        <span class="n">metrics</span><span class="o">,</span>
        <span class="n">metricGrpPrefix</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">time</span><span class="o">,</span>
        <span class="k">this</span><span class="o">.</span><span class="na">retryBackoffMs</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>它们都封装了刚才的client、subscriptions。从命名上推测，coordinator负责与Kafka Server的协调工作，fetcher负责拉取数据。它们与Kafka Server的通信都依靠client对象。</p>
<p>注意到coordinator还封装了一个assignors对象，这个对象有重要作用。</p>
<p>整个构造方法除了初始化以外几乎没有做别的操作，也没有创建其他的线程。</p>
<h2 id="subscriptionstate的作用">SubscriptionState的作用</h2>
<p>构造好一个consumer对象后，可以订阅topics：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">consumer</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="s">&#34;test1&#34;</span><span class="o">,</span> <span class="s">&#34;test2&#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>消费端有多种订阅topics的方式，上面这种方式是通过topic名称来订阅。还可以直接通过指定TopicPartition来进行消费，调用的是assign方法，但内部都是对SubscriptionState对象，即上面的subscriptions进行操作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">topics</span><span class="o">,</span> <span class="n">ConsumerRebalanceListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">acquire</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">topics</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// treat subscribing to empty topic list as the same as unsubscribing
</span><span class="c1"></span>            <span class="k">this</span><span class="o">.</span><span class="na">unsubscribe</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Subscribed to topic(s): {}&#34;</span><span class="o">,</span> <span class="n">Utils</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">topics</span><span class="o">,</span> <span class="s">&#34;, &#34;</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">topics</span><span class="o">,</span> <span class="n">listener</span><span class="o">)</span><span class="o">;</span>
            <span class="n">metadata</span><span class="o">.</span><span class="na">setTopics</span><span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">groupSubscription</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">release</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的acquire和release方法是与锁有关的操作，比较简单，本文不讨论。</p>
<p>如果指定的topics为空，那么直接用unsubscribe方法清空内部信息。否则调用subscribe方法进行订阅。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">subscribe</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">topics</span><span class="o">,</span> <span class="n">ConsumerRebalanceListener</span> <span class="n">listener</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">listener</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="o">(</span><span class="s">&#34;RebalanceListener cannot be null&#34;</span><span class="o">)</span><span class="o">;</span>

    <span class="n">setSubscriptionType</span><span class="o">(</span><span class="n">SubscriptionType</span><span class="o">.</span><span class="na">AUTO_TOPICS</span><span class="o">)</span><span class="o">;</span>

    <span class="k">this</span><span class="o">.</span><span class="na">listener</span> <span class="o">=</span> <span class="n">listener</span><span class="o">;</span>

    <span class="n">changeSubscription</span><span class="o">(</span><span class="n">topics</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中setSubscriptionType方法用来指定SubscriptionType。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setSubscriptionType</span><span class="o">(</span><span class="n">SubscriptionType</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">subscriptionType</span> <span class="o">=</span><span class="o">=</span> <span class="n">SubscriptionType</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subscriptionType</span> <span class="o">=</span> <span class="n">type</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">subscriptionType</span> <span class="o">!</span><span class="o">=</span> <span class="n">type</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="n">SUBSCRIPTION_EXCEPTION_MESSAGE</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在构造方法中进行初始化时没有指定类型，所以一开始是None，因此这里可以根据传入的类型进行覆盖。</p>
<p>SubscriptionType是一个枚举：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">enum</span> <span class="n">SubscriptionType</span> <span class="o">{</span>
    <span class="n">NONE</span><span class="o">,</span> <span class="n">AUTO_TOPICS</span><span class="o">,</span> <span class="n">AUTO_PATTERN</span><span class="o">,</span> <span class="n">USER_ASSIGNED</span>
<span class="o">}</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>如果调用了上面的subscribe方法，那么类型就被设置为了AUTO_TOPICS。如果调用的是另一个重载的subscribe方法，传入的不是topic的名称，而是pattern，那么类型就会被设置为AUTO_PATTERN。如果调用的是assign方法，那么类型就是USER_ASSIGNED。我们在使用FlinkKafkaConsumer时虽然指定了topic的名称，但是其内部实际上是先获取了metadata信息，再根据topic名称从metadata中获取TopicPartition信息，然后直接指定的TopicPartition，因此调用的是assign方法。从setSubscriptionType方法可以看出，不允许同时指定多种订阅类型。</p>
<p>随后调用changeSubscription方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeSubscription</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">topicsToSubscribe</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="k">this</span><span class="o">.</span><span class="na">subscription</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">topicsToSubscribe</span><span class="o">)</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subscription</span><span class="o">.</span><span class="na">clear</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">subscription</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">topicsToSubscribe</span><span class="o">)</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">groupSubscription</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">topicsToSubscribe</span><span class="o">)</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">needsPartitionAssignment</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="c1">// Remove any assigned partitions which are no longer subscribed to
</span><span class="c1"></span>        <span class="k">for</span> <span class="o">(</span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">assignment</span><span class="o">.</span><span class="na">keySet</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">(</span><span class="o">)</span><span class="o">;</span> <span class="o">)</span> <span class="o">{</span>
            <span class="n">TopicPartition</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">subscription</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">tp</span><span class="o">.</span><span class="na">topic</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">)</span>
                <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它将订阅的topic名称放入了subscription和groupSubscription中，然后将assignment清空。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/* the list of topics the user has requested */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">subscription</span><span class="o">;</span>

<span class="cm">/* the list of topics the group has subscribed to (set only for the leader on join group completion) */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">groupSubscription</span><span class="o">;</span>

<span class="cm">/* the list of partitions currently assigned */</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">TopicPartitionState</span><span class="o">&gt;</span> <span class="n">assignment</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>其中assignment这个Map的value为TopicPartitionState类型，它包含了每一个TopicPartition的消费情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TopicPartitionState</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Long</span> <span class="n">position</span><span class="o">;</span> <span class="c1">// last consumed position
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">OffsetAndMetadata</span> <span class="n">committed</span><span class="o">;</span>  <span class="c1">// last committed position
</span><span class="c1"></span>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">paused</span><span class="o">;</span>  <span class="c1">// whether this partition has been paused by the user
</span><span class="c1"></span>    <span class="kd">private</span> <span class="n">OffsetResetStrategy</span> <span class="n">resetStrategy</span><span class="o">;</span>  <span class="c1">// the strategy to use if the offset needs resetting
</span></code></pre></td></tr></table>
</div>
</div><p>从它的属性可以看出，KafkaConsumer端维护了两个offset信息。一个是position字段，表示最近消费的offset；另一个是committed，表示最近提交的offset。</p>
<p>这里可以对这两个字段的更新方式做出猜测：position应该是在消费完一条数据后就进行更新，此后会调用某个方法给Kafka Server发一个请求，即一个commit request，表示对刚消费完的那个offset进行提交，更新到zookeeper或其他地方（取决于该版本的Kafka用什么方式维护消费者的offset），当收到对应的响应时更新committed字段。这样一来，如果先消费了数据，此时还没来得及提交commit request就发生了宕机，之后恢复时，消费者从Kafka Server端获取到的offset是比较老的offset，再次消费就会出现at least once语义。如果我们可以调整position字段和committed字段的更新方式、顺序，那么则可能可以构造出其他一致性语义。</p>
<p>当然，以上只是基于字段做出的猜测，接下来可以留意一下consumer端一般是如何更新它们的。</p>
<p>subscribe方法最后更新了metadata：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">metadata</span><span class="o">.</span><span class="na">setTopics</span><span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">groupSubscription</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>由此可以得知，subscriptions字段保存的是topics订阅信息以及它们的消费情况。</p>
<h2 id="kafkaconsumer的poll方法">KafkaConsumer的poll方法</h2>
<p>业务代码中会通过consumer的poll方法拉取数据，这个方法是整个consumer端最重要的方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">acquire</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
        <span class="k">do</span> <span class="o">{</span>
            <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">pollOnce</span><span class="o">(</span><span class="n">remaining</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">records</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fetcher</span><span class="o">.</span><span class="na">sendFetches</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">client</span><span class="o">.</span><span class="na">pollNoWakeup</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

                <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">interceptors</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">records</span><span class="o">)</span><span class="o">;</span>
                <span class="k">else</span>
                    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">interceptors</span><span class="o">.</span><span class="na">onConsume</span><span class="o">(</span><span class="k">new</span> <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">records</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">long</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">milliseconds</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="n">timeout</span> <span class="o">-</span> <span class="n">elapsed</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span><span class="o">;</span>

        <span class="k">return</span> <span class="n">ConsumerRecords</span><span class="o">.</span><span class="na">empty</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">release</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从整体上看这个方法，只有pollOnce方法可以获取到数据。但是获取到数据后并没有直接返回，而是进入了if分支。这与直觉不同，因为直觉上我们会认为如果records不为空时该直接返回，如果为空时才会进入分支，也许会做一些再次发起请求的操作。而这里正相反。</p>
<p>在if分支中，调用了fetcher.sendFetchers()方法和client.pollNoWakeup()方法。此时还不知道它们的作用，因此先跳过这个分支的分析，直接进入到pollOnce方法。等pollOnce方法分析完后，自然就知道if分支的作用了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">pollOnce</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1.与GroupCoordinator建立连接。
</span><span class="c1"></span>    <span class="n">coordinator</span><span class="o">.</span><span class="na">ensureCoordinatorReady</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 2.partition的分配。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">partitionsAutoAssigned</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="n">coordinator</span><span class="o">.</span><span class="na">ensurePartitionAssignment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 3.更新offset。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">hasAllFetchPositions</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="n">updateFetchPositions</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">.</span><span class="na">missingFetchPositions</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

    <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">milliseconds</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 4.执行延迟任务。
</span><span class="c1"></span>    <span class="n">client</span><span class="o">.</span><span class="na">executeDelayedTasks</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 5.拉取消息。
</span><span class="c1"></span>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">records</span> <span class="o">=</span> <span class="n">fetcher</span><span class="o">.</span><span class="na">fetchedRecords</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 6.如果拉取到消息则直接返回。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">records</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">records</span><span class="o">;</span>

    <span class="c1">// 7.构造拉取数据的请求并缓存。
</span><span class="c1"></span>    <span class="n">fetcher</span><span class="o">.</span><span class="na">sendFetches</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    
    <span class="c1">// 8.发送请求、接收响应、处理响应。
</span><span class="c1"></span>    <span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="n">now</span><span class="o">)</span><span class="o">;</span>
  
    <span class="c1">// 9.拉取消息。
</span><span class="c1"></span>    <span class="k">return</span> <span class="n">fetcher</span><span class="o">.</span><span class="na">fetchedRecords</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法几乎全部都是对coordinator、fetcher和client的操作。注意这个方法中出现的client都是ConsumerNetworkClient对象，它内部封装了NetworkClient对象。</p>
<h3 id="consumercoordinator">ConsumerCoordinator</h3>
<p>第一步和第二步涉及到coordinator。这个coordinator有什么用？</p>
<p>Kafka中同一个消费者组的每个consumer能够消费一个或者多个特定的TopicPartition中的数据，因此一开始就需要给每个consumer分配好它应该去消费哪个分区。KafkaConsumer端会跟Kafka Server端的GroupCoodinator组件通信，先发送一个请求找到这个GroupCoordinator的位置，然后所有consumer都往该节点发送JoinGroup请求，GroupCoodinator会选择一个consumer作为leader。这个leader会完成TopicPartition的分配。最后所有consumer发送SyncGroup请求，获取这个分配结果。整个过程中，KafkaConsumer端负责与GroupCoordinator通信的对象就是这个coordinator字段。</p>
<p>第一步与GroupCoordinator建立连接。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">ensureCoordinatorReady</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">coordinatorUnknown</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendGroupCoordinatorRequest</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">failed</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
          
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
            
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">coordinator</span> <span class="o">!</span><span class="o">=</span> <span class="kc">null</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="n">client</span><span class="o">.</span><span class="na">connectionFailed</span><span class="o">(</span><span class="n">coordinator</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
          
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
            
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是一个while循环，判断的条件是coordinatorUnknown方法，这个方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">coordinatorUnknown</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">coordinator</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">connectionFailed</span><span class="o">(</span><span class="n">coordinator</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">coordinatorDead</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注意这个方法里的coordinator是上面ConsumerCoordinator类的一个字段，为Node类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="n">Node</span> <span class="n">coordinator</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>因此这个方法的含义很简单，即还没连上时返回true，一直进行循环。循环的目的就是进行连接，主要逻辑就是前两行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendGroupCoordinatorRequest</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>第一行可以理解为构造请求，并将请求缓存起来。第二行将请求取出来发送出去。这种操作在Consumer端还有多处用到。比如pollOnce方法的第七步和第八步，也是先构造请求并缓存，然后发送出去。再一次强调，这个client不是NetworkClient类的对象，而是ConsumerNetworkClient，因此它的poll方法内部不仅封装了NetworkClient的poll方法，还封装了许多其他操作。</p>
<p>接下来详细分析sendGroupCoordinatorRequest方法和poll方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">sendGroupCoordinatorRequest</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">client</span><span class="o">.</span><span class="na">leastLoadedNode</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Sending coordinator request for group {} to broker {}&#34;</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">// 1.构造请求。
</span><span class="c1"></span>        <span class="n">GroupCoordinatorRequest</span> <span class="n">metadataRequest</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GroupCoordinatorRequest</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">groupId</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">// 2.缓存请求。
</span><span class="c1"></span>        <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">GROUP_COORDINATOR</span><span class="o">,</span> <span class="n">metadataRequest</span><span class="o">)</span>
                <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureAdapter</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 3.添加回调操作。
</span><span class="c1"></span>                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">handleGroupMetadataResponse</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">future</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>选择一个Node来构造请求，然后调用send方法缓存请求。之后还可以看到每一次构造请求后都会调用这个方法去缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">&gt;</span> <span class="nf">send</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span>
                                          <span class="n">ApiKeys</span> <span class="n">api</span><span class="o">,</span>
                                          <span class="n">AbstractRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="na">milliseconds</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">RequestFutureCompletionHandler</span> <span class="n">future</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RequestFutureCompletionHandler</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">RequestHeader</span> <span class="n">header</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="na">nextRequestHeader</span><span class="o">(</span><span class="n">api</span><span class="o">)</span><span class="o">;</span>
    <span class="n">RequestSend</span> <span class="n">send</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RequestSend</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">idString</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">header</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">toStruct</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="n">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="k">new</span> <span class="n">ClientRequest</span><span class="o">(</span><span class="n">now</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">send</span><span class="o">,</span> <span class="n">future</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">future</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里注意两个点。一个是构造了一个future对象并返回，另一个是put方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="n">ClientRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">ClientRequest</span><span class="o">&gt;</span> <span class="n">nodeUnsent</span> <span class="o">=</span> <span class="n">unsent</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nodeUnsent</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">nodeUnsent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">unsent</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">nodeUnsent</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">nodeUnsent</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">request</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里将请求放入了unsent队列。unsent是一个Map，key表示一个节点，value表示要发往这个节点的请求。</p>
<p>缓存请求后，返回了一个future对象，类型为RequestFutureCompletionHandler。这个对象可以给它添加回调函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">RequestFutureCompletionHandler</span>
        <span class="kd">extends</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">&gt;</span>
        <span class="kd">implements</span> <span class="n">RequestCompletionHandler</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onComplete</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">response</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">wasDisconnected</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ClientRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">response</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">RequestSend</span> <span class="n">send</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">ApiKeys</span> <span class="n">api</span> <span class="o">=</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">forId</span><span class="o">(</span><span class="n">send</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">apiKey</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">correlation</span> <span class="o">=</span> <span class="n">send</span><span class="o">.</span><span class="na">header</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">correlationId</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Cancelled {} request {} with correlation id {} due to node {} being disconnected&#34;</span><span class="o">,</span>
                    <span class="n">api</span><span class="o">,</span> <span class="n">request</span><span class="o">,</span> <span class="n">correlation</span><span class="o">,</span> <span class="n">send</span><span class="o">.</span><span class="na">destination</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="n">raise</span><span class="o">(</span><span class="n">DisconnectException</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">complete</span><span class="o">(</span><span class="n">response</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个类继承了RequestFuture，又实现了RequestCompletionHandler，看起来非常复杂。实际上很简单。实现RequestCompletionHandler是因为获取到响应后要从响应中取到请求，再从请求中取到callback对象调用其回调方法。ClientRequest类的callback字段的类型就是RequestCompletionHandler，所以必须要实现该接口。</p>
<p>而在调用该接口的唯一方法onComplete时，就可以做很多灵活的处理。因为会有多种请求，每个请求收到响应后都会做不同的处理，甚至我们希望这些回调操作可以以监听器的形式随时添加或删除一个或多个，我们没有必要多次实现RequestCompletionHandler接口的onComplete方法。于是Kafka在设计上让RequestFutureCompletionHandler还继承了RequestFuture类，在onComplete方法中调用了RequestFuture的complete方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">complete</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isDone</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="o">(</span><span class="s">&#34;Invalid attempt to complete a request future which is already complete&#34;</span><span class="o">)</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">isDone</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="n">fireSuccess</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kt">void</span> <span class="nf">fireSuccess</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">listener</span> <span class="o">:</span> <span class="n">listeners</span><span class="o">)</span>
        <span class="n">listener</span><span class="o">.</span><span class="na">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到最后是遍历调用了监听器的onSuccess方法。那么这些监听器是什么时候注册的呢？</p>
<p>注意到client.send方法的返回值就是future对象，在上面sendGroupCoordinatorRequest方法中标记的第三步，调用了compose方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="nf">compose</span><span class="o">(</span><span class="kd">final</span> <span class="n">RequestFutureAdapter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">,</span> <span class="n">S</span><span class="o">&gt;</span> <span class="n">adapter</span><span class="o">)</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">adapted</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">adapter</span><span class="o">.</span><span class="na">onSuccess</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">adapted</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">adapter</span><span class="o">.</span><span class="na">onFailure</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">adapted</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span><span class="o">)</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">adapted</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个compose方法，就是RequestFuture中的一个方法，它调用了addListener方法添加了监听器。而这个监听器的onSuccess方法，调用了传入的参数的onSuccess方法。传入的参数正如代码中所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">GROUP_COORDINATOR</span><span class="o">,</span> <span class="n">metadataRequest</span><span class="o">)</span>
        <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureAdapter</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">handleGroupMetadataResponse</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">future</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>compose方法的返回值是方法内部构造的那个RequestFuture对象，这个对象也就是sendGroupCoordinatorRequest方法的返回值，这个对象同时还传入了onSuccess方法中，作为handleGroupMetadataResponse方法的参数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">handleGroupMetadataResponse</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">resp</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Received group coordinator response {}&#34;</span><span class="o">,</span> <span class="n">resp</span><span class="o">)</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">coordinatorUnknown</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">GroupCoordinatorResponse</span> <span class="n">groupCoordinatorResponse</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GroupCoordinatorResponse</span><span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">responseBody</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
        <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 1.给coordinator字段赋值。
</span><span class="c1"></span>            <span class="k">this</span><span class="o">.</span><span class="na">coordinator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span> <span class="o">-</span> <span class="n">groupCoordinatorResponse</span><span class="o">.</span><span class="na">node</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">id</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
                    <span class="n">groupCoordinatorResponse</span><span class="o">.</span><span class="na">node</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">host</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
                    <span class="n">groupCoordinatorResponse</span><span class="o">.</span><span class="na">node</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">port</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Discovered coordinator {} for group {}.&#34;</span><span class="o">,</span> <span class="n">coordinator</span><span class="o">,</span> <span class="n">groupId</span><span class="o">)</span><span class="o">;</span>
            <span class="c1">// 2.对该节点建立连接。
</span><span class="c1"></span>            <span class="n">client</span><span class="o">.</span><span class="na">tryConnect</span><span class="o">(</span><span class="n">coordinator</span><span class="o">)</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">generation</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span>
                <span class="n">heartbeatTask</span><span class="o">.</span><span class="na">reset</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="c1">// 3.标记完成。
</span><span class="c1"></span>            <span class="n">future</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">GROUP_AUTHORIZATION_FAILED</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">future</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="n">GroupAuthorizationException</span><span class="o">(</span><span class="n">groupId</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">future</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="n">error</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该方法做的事情如上面注释所描述。future.complete的逻辑上面也已贴出，它将isDone字段变为true。</p>
<p>总结整个调用链条：</p>
<p>收到响应后，会调用callback的onComplete方法（即RequestFutureCompletionHandler类的onComplete方法），这个callback就是构造请求时构造的那个future对象（称这个对象为future1）。onComplete方法会遍历监听器，调用其onSuccess方法。监听器是client.send方法后面的compose方法中添加的，这个方法的参数是RequestFutureAdapter类的对象（这里用到了适配器模式），这个方法返回了另一个future对象（称这个对象为future2），该对象还是RequestFutureAdapter的onSuccess方法的一个参数。调用监听器的onSuccess方法会调用到RequestFutureAdapter的onSuccess方法，这个方法对特定请求特定响应做特定处理。这里建立了连接，并将future2对象中的isDone置为了true。</p>
<p>整个链条比较长，建议多看几遍源码。</p>
<p>在后面各种请求中，会反复出现类似下面这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">GROUP_COORDINATOR</span><span class="o">,</span> <span class="n">metadataRequest</span><span class="o">)</span>
        <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureAdapter</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">,</span> <span class="n">Void</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">response</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">handleGroupMetadataResponse</span><span class="o">(</span><span class="n">response</span><span class="o">,</span> <span class="n">future</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>现在已经理清了调用链，因此之后只需要关注RequestFutureAdapter的onSuccess方法中的那个方法即可。该方法一般也是见名知义，比如这里就是处理GroupMetadata的响应，名称为handleGroupMetadataResponse。</p>
<p>sendGroupCoordinatorRequest方法的返回值是future对象，下一行执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">poll</span><span class="o">(</span><span class="n">RequestFuture</span><span class="o">&lt;</span><span class="o">?</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="o">!</span><span class="n">future</span><span class="o">.</span><span class="na">isDone</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="n">poll</span><span class="o">(</span><span class="n">Long</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到这里用到了isDone做判断，如果没有收到响应并正确处理，则会一直在这里循环，可以理解为阻塞在了这里。而这个poll方法则完成了请求发送和处理响应的操作（否则也不会一直循环poll方法）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">now</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">executeDelayedTasks</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1.将请求赋给KafkaChannel的send字段。
</span><span class="c1"></span>    <span class="n">trySend</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>

    <span class="n">timeout</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="n">delayedTasks</span><span class="o">.</span><span class="na">nextTimeout</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="c1">// 2.发送请求和处理响应。
</span><span class="c1"></span>    <span class="n">clientPoll</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="n">now</span><span class="o">)</span><span class="o">;</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

    <span class="c1">// 3.处理定时任务。
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">executeDelayedTasks</span><span class="o">)</span>
        <span class="n">delayedTasks</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>

    <span class="n">trySend</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// 4.处理过期请求。
</span><span class="c1"></span>    <span class="n">failExpiredRequests</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>之前已经说过，每次构造完请求并缓存后，都会进入到poll方法，把请求发送出去。因此在后面的代码执行逻辑中还会反复来到这个poll方法。分析清楚这个方法的作用，则解决了后面很多的问题。</p>
<p>注意到上面出现了两次trySend方法。不用纠结这样设计的目的，可以理解为这样更加高效。</p>
<p>其中trySend方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">trySend</span><span class="o">(</span><span class="kt">long</span> <span class="n">now</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// send any requests that can be sent now
</span><span class="c1"></span>    <span class="kt">boolean</span> <span class="n">requestsSent</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ClientRequest</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">requestEntry</span><span class="o">:</span> <span class="n">unsent</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">requestEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">ClientRequest</span><span class="o">&gt;</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">requestEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">iterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">ClientRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">client</span><span class="o">.</span><span class="na">ready</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">now</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">request</span><span class="o">,</span> <span class="n">now</span><span class="o">)</span><span class="o">;</span>
                <span class="n">iterator</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">requestsSent</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">requestsSent</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>主要逻辑是从unsent队列中取出刚才放入的请求，调用client.send赋给KafkaChannel的send字段。注意这里的client是NetworkClient类型了。思路与Producer端一致。</p>
<p>这里保留一个疑问，就是在debug的过程中发现unsent队列中始终只有一个请求。而且假设有多个请求在队列中，在遍历时后面的请求一定会覆盖之前赋给send字段的值。暂时不明白这样设计的用意。</p>
<p>clientPoll方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kt">void</span> <span class="nf">clientPoll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">now</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="n">now</span><span class="o">)</span><span class="o">;</span>
    <span class="n">maybeTriggerWakeup</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法就进入到了非常熟悉的代码片段了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">&gt;</span> <span class="nf">poll</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="kt">long</span> <span class="n">now</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">metadataTimeout</span> <span class="o">=</span> <span class="n">metadataUpdater</span><span class="o">.</span><span class="na">maybeUpdate</span><span class="o">(</span><span class="n">now</span><span class="o">)</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">selector</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">Utils</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="n">metadataTimeout</span><span class="o">,</span> <span class="n">requestTimeoutMs</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IOException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;Unexpected error during I/O&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// process completed actions
</span><span class="c1"></span>    <span class="kt">long</span> <span class="n">updatedNow</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">time</span><span class="o">.</span><span class="na">milliseconds</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">&gt;</span> <span class="n">responses</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">handleCompletedSends</span><span class="o">(</span><span class="n">responses</span><span class="o">,</span> <span class="n">updatedNow</span><span class="o">)</span><span class="o">;</span>
    <span class="n">handleCompletedReceives</span><span class="o">(</span><span class="n">responses</span><span class="o">,</span> <span class="n">updatedNow</span><span class="o">)</span><span class="o">;</span>
    <span class="n">handleDisconnections</span><span class="o">(</span><span class="n">responses</span><span class="o">,</span> <span class="n">updatedNow</span><span class="o">)</span><span class="o">;</span>
    <span class="n">handleConnections</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">handleTimedOutRequests</span><span class="o">(</span><span class="n">responses</span><span class="o">,</span> <span class="n">updatedNow</span><span class="o">)</span><span class="o">;</span>

    <span class="c1">// invoke callbacks
</span><span class="c1"></span>    <span class="k">for</span> <span class="o">(</span><span class="n">ClientResponse</span> <span class="n">response</span> <span class="o">:</span> <span class="n">responses</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">hasCallback</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">response</span><span class="o">.</span><span class="na">request</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">callback</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">onComplete</span><span class="o">(</span><span class="n">response</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;Uncaught error in request completion:&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">responses</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>因此这个clientPoll方法就做了发送请求和接受响应并处理响应的所有操作。</p>
<p>剩下的还有处理定时任务和过期请求的操作，不是非常重要。</p>
<p>至此ensureCoordinatorReady方法分析完毕。该方法结束后建立了GroupCoordinator的连接。下面来到pollOnce方法的第二个步骤，分配partition：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">partitionsAutoAssigned</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
    <span class="n">coordinator</span><span class="o">.</span><span class="na">ensurePartitionAssignment</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>判断条件为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">partitionsAutoAssigned</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">subscriptionType</span> <span class="o">=</span><span class="o">=</span> <span class="n">SubscriptionType</span><span class="o">.</span><span class="na">AUTO_TOPICS</span> <span class="o">|</span><span class="o">|</span> <span class="k">this</span><span class="o">.</span><span class="na">subscriptionType</span> <span class="o">=</span><span class="o">=</span> <span class="n">SubscriptionType</span><span class="o">.</span><span class="na">AUTO_PATTERN</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这与之前的理解一致。只有AUTO_TOPICS和AUTO_PATTERN需要进行分配。如果用户指定了去消费哪个TopicPartition，则无需这一步骤。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">ensurePartitionAssignment</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">partitionsAutoAssigned</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">hasPatternSubscription</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
            <span class="n">client</span><span class="o">.</span><span class="na">ensureFreshMetadata</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">ensureActiveGroup</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>


<span class="kd">public</span> <span class="kt">void</span> <span class="nf">ensureActiveGroup</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">needRejoin</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">needsJoinPrepare</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1.JoinGroup前的准备工作。
</span><span class="c1"></span>        <span class="n">onJoinPrepare</span><span class="o">(</span><span class="n">generation</span><span class="o">,</span> <span class="n">memberId</span><span class="o">)</span><span class="o">;</span>
        <span class="n">needsJoinPrepare</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">while</span> <span class="o">(</span><span class="n">needRejoin</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        <span class="c1">// 2.构造JoinGroup请求。
</span><span class="c1"></span>        <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendJoinGroupRequest</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">// 3.添加监听器。
</span><span class="c1"></span>        <span class="n">future</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ByteBuffer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// handle join completion in the callback so that the callback will be invoked
</span><span class="c1"></span>                <span class="c1">// even if the consumer is woken up before finishing the rebalance
</span><span class="c1"></span>                <span class="n">onJoinComplete</span><span class="o">(</span><span class="n">generation</span><span class="o">,</span> <span class="n">memberId</span><span class="o">,</span> <span class="n">protocol</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
                <span class="n">needsJoinPrepare</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">heartbeatTask</span><span class="o">.</span><span class="na">reset</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// we handle failures below after the request finishes. if the join completes
</span><span class="c1"></span>                <span class="c1">// after having been woken up, the exception is ignored and we will rejoin
</span><span class="c1"></span>            <span class="o">}</span>
        <span class="o">}</span><span class="o">)</span><span class="o">;</span>
        <span class="c1">// 4.发送请求并处理响应。
</span><span class="c1"></span>        <span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>

      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在这个方法里面会执行之前说过的JoinGroup和SyncGroup操作。</p>
<p>首先在JoinGroup前还需要一些准备工作。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onJoinPrepare</span><span class="o">(</span><span class="kt">int</span> <span class="n">generation</span><span class="o">,</span> <span class="n">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// commit offsets prior to rebalance if auto-commit enabled
</span><span class="c1"></span>    <span class="n">maybeAutoCommitOffsetsSync</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
<span class="o">}</span>


<span class="kd">private</span> <span class="kt">void</span> <span class="nf">maybeAutoCommitOffsetsSync</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">autoCommitEnabled</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">commitOffsetsSync</span><span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">allConsumed</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">WakeupException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
            
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这是要发送commitOffset的请求，可见Kafka的确提供了api和协议来让我们自己决定什么时候commit offset。commitOffsetsSync的参数如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">OffsetAndMetadata</span><span class="o">&gt;</span> <span class="nf">allConsumed</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">OffsetAndMetadata</span><span class="o">&gt;</span> <span class="n">allConsumed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">TopicPartitionState</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">assignment</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TopicPartitionState</span> <span class="n">state</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">hasValidPosition</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
            <span class="n">allConsumed</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="k">new</span> <span class="n">OffsetAndMetadata</span><span class="o">(</span><span class="n">state</span><span class="o">.</span><span class="na">position</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">allConsumed</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个assignment之前已经见过，就是SubscriptionState中的一个字段，维护了每个TopicPartition的消费情况。state.position就是获取最新消费的offset。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">commitOffsetsSync</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">OffsetAndMetadata</span><span class="o">&gt;</span> <span class="n">offsets</span><span class="o">)</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">ensureCoordinatorReady</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendOffsetCommitRequest</span><span class="o">(</span><span class="n">offsets</span><span class="o">)</span><span class="o">;</span>
        <span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中这两行代码似曾相识：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendOffsetCommitRequest</span><span class="o">(</span><span class="n">offsets</span><span class="o">)</span><span class="o">;</span>
<span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这也是一个阻塞的方法，与之前建立连接时的处理方式完全一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">sendOffsetCommitRequest</span><span class="o">(</span><span class="kd">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">OffsetAndMetadata</span><span class="o">&gt;</span> <span class="n">offsets</span><span class="o">)</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

    <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">coordinator</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">OFFSET_COMMIT</span><span class="o">,</span> <span class="n">req</span><span class="o">)</span>
            <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">OffsetCommitResponseHandler</span><span class="o">(</span><span class="n">offsets</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>根据之前的分析，OffsetCommitResponseHandler类一定是用来处理对应的响应。它继承了CoordinatorResponseHandler类，最终会调用到handle方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">OffsetCommitResponse</span> <span class="n">commitResponse</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">sensors</span><span class="o">.</span><span class="na">commitLatency</span><span class="o">.</span><span class="na">record</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">requestLatencyMs</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">unauthorizedTopics</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">Short</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">commitResponse</span><span class="o">.</span><span class="na">responseData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TopicPartition</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">OffsetAndMetadata</span> <span class="n">offsetAndMetadata</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">offsets</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">tp</span><span class="o">)</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">offsetAndMetadata</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="n">Errors</span> <span class="n">error</span> <span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">forCode</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Group {} committed offset {} for partition {}&#34;</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="n">offset</span><span class="o">,</span> <span class="n">tp</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">isAssigned</span><span class="o">(</span><span class="n">tp</span><span class="o">)</span><span class="o">)</span>
                <span class="c1">// update the local cache only if the partition is still assigned
</span><span class="c1"></span>                <span class="n">subscriptions</span><span class="o">.</span><span class="na">committed</span><span class="o">(</span><span class="n">tp</span><span class="o">,</span> <span class="n">offsetAndMetadata</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">GROUP_AUTHORIZATION_FAILED</span><span class="o">)</span> <span class="o">{</span>
          
            <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
              
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">unauthorizedTopics</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&#34;Not authorized to commit to topics {} for group {}&#34;</span><span class="o">,</span> <span class="n">unauthorizedTopics</span><span class="o">,</span> <span class="n">groupId</span><span class="o">)</span><span class="o">;</span>
          <span class="n">future</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="n">TopicAuthorizationException</span><span class="o">(</span><span class="n">unauthorizedTopics</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="n">future</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="kc">null</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>接收到响应以后，更新subscriptions中的committed字段。这便是JoinGroup前的准备工作。</p>
<p>接下来构造并发送JoinGroup的请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="n">future</span> <span class="o">=</span> <span class="n">sendJoinGroupRequest</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
<span class="n">future</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ByteBuffer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// handle join completion in the callback so that the callback will be invoked
</span><span class="c1"></span>        <span class="c1">// even if the consumer is woken up before finishing the rebalance
</span><span class="c1"></span>        <span class="n">onJoinComplete</span><span class="o">(</span><span class="n">generation</span><span class="o">,</span> <span class="n">memberId</span><span class="o">,</span> <span class="n">protocol</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
        <span class="n">needsJoinPrepare</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">heartbeatTask</span><span class="o">.</span><span class="na">reset</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// we handle failures below after the request finishes. if the join completes
</span><span class="c1"></span>        <span class="c1">// after having been woken up, the exception is ignored and we will rejoin
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span><span class="o">)</span><span class="o">;</span>
<span class="n">client</span><span class="o">.</span><span class="na">poll</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到这里又是同样的套路，构造请求后发送出去，并且是一个阻塞的操作。只不过中间添加了一个监听器。这个监听器稍后再回来分析，先看sendJoinGroupRequest方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="nf">sendJoinGroupRequest</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
    <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">coordinator</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">JOIN_GROUP</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
            <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">JoinGroupResponseHandler</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>只需看收到响应后的操作，即JoinGroupResponseHandler中的内容。它也继承了CoordinatorResponseHandler类，观察其handle方法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">JoinGroupResponse</span> <span class="n">joinResponse</span><span class="o">,</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Errors</span> <span class="n">error</span> <span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">forCode</span><span class="o">(</span><span class="n">joinResponse</span><span class="o">.</span><span class="na">errorCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
          
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
            
            <span class="k">if</span> <span class="o">(</span><span class="n">joinResponse</span><span class="o">.</span><span class="na">isLeader</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">onJoinLeader</span><span class="o">(</span><span class="n">joinResponse</span><span class="o">)</span><span class="o">.</span><span class="na">chain</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">onJoinFollower</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">chain</span><span class="o">(</span><span class="n">future</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">GROUP_LOAD_IN_PROGRESS</span><span class="o">)</span> <span class="o">{</span>
          
            <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
              
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>根据前面对compose方法的分析，可以很容易看出来handle方法的入参future就是sendJoinGroupRequest返回的那个future对象。这个方法中没有直接调用future.complete方法标记处理完成，而是调用了一个chain方法将其传入进去。我们知道只有调用了complete方法，才会调用该future对象的监听器的onSuccess方法。</p>
<p>这里对leader和follower分开处理。我们只看leader。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="nf">onJoinLeader</span><span class="o">(</span><span class="n">JoinGroupResponse</span> <span class="n">joinResponse</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// perform the leader synchronization and send back the assignment for the group
</span><span class="c1"></span>        <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="n">groupAssignment</span> <span class="o">=</span> <span class="n">performAssignment</span><span class="o">(</span><span class="n">joinResponse</span><span class="o">.</span><span class="na">leaderId</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">joinResponse</span><span class="o">.</span><span class="na">groupProtocol</span><span class="o">(</span><span class="o">)</span><span class="o">,</span>
                <span class="n">joinResponse</span><span class="o">.</span><span class="na">members</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>

        <span class="n">SyncGroupRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SyncGroupRequest</span><span class="o">(</span><span class="n">groupId</span><span class="o">,</span> <span class="n">generation</span><span class="o">,</span> <span class="n">memberId</span><span class="o">,</span> <span class="n">groupAssignment</span><span class="o">)</span><span class="o">;</span>
        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Sending leader SyncGroup for group {} to coordinator {}: {}&#34;</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">coordinator</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">sendSyncGroupRequest</span><span class="o">(</span><span class="n">request</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">RequestFuture</span><span class="o">.</span><span class="na">failure</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>它的返回值也是一个RequestFuture对象。而chain方法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">chain</span><span class="o">(</span><span class="kd">final</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">future</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="n">value</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">future</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>也就是说，只有调用到onJoinLeader方法中某个方法构造的某个future对象的complete方法时，才会调用到这个chain方法中的future对象的complete方法。</p>
<p>onJoinLeader方法第一步是performAssignment，就是对TopicPartition给每个consumer进行分配。</p>
<p>那么根据什么策略来分配呢？在JoinGroup的响应中，Kafka Server已经给Consumer端选择好了策略，即joinResponse.groupProtocol()方法的返回值。具体分配逻辑本文不展开讨论。</p>
<p>分配好以后，需要发送SyncGroup请求。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="nf">sendSyncGroupRequest</span><span class="o">(</span><span class="n">SyncGroupRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">coordinatorUnknown</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
        <span class="k">return</span> <span class="n">RequestFuture</span><span class="o">.</span><span class="na">coordinatorNotAvailable</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">coordinator</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">SYNC_GROUP</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
            <span class="o">.</span><span class="na">compose</span><span class="o">(</span><span class="k">new</span> <span class="n">SyncGroupResponseHandler</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>同理，只需分析SyncGroupResponseHandler如何处理响应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="n">SyncGroupResponse</span> <span class="n">syncResponse</span><span class="o">,</span>
                   <span class="n">RequestFuture</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span> <span class="n">future</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Errors</span> <span class="n">error</span> <span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">forCode</span><span class="o">(</span><span class="n">syncResponse</span><span class="o">.</span><span class="na">errorCode</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">error</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NONE</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;Successfully joined group {} with generation {}&#34;</span><span class="o">,</span> <span class="n">groupId</span><span class="o">,</span> <span class="n">generation</span><span class="o">)</span><span class="o">;</span>
        <span class="n">sensors</span><span class="o">.</span><span class="na">syncLatency</span><span class="o">.</span><span class="na">record</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">requestLatencyMs</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="n">future</span><span class="o">.</span><span class="na">complete</span><span class="o">(</span><span class="n">syncResponse</span><span class="o">.</span><span class="na">memberAssignment</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
      
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里的future就是sendSyncGroupRequest方法中client.send方法新生成的future对象，它的complete方法会调用到上面那个chain的future对象的complete方法，最后执行最外部的那个监听器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">future</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">ByteBuffer</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ByteBuffer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// handle join completion in the callback so that the callback will be invoked
</span><span class="c1"></span>        <span class="c1">// even if the consumer is woken up before finishing the rebalance
</span><span class="c1"></span>        <span class="n">onJoinComplete</span><span class="o">(</span><span class="n">generation</span><span class="o">,</span> <span class="n">memberId</span><span class="o">,</span> <span class="n">protocol</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span><span class="o">;</span>
        <span class="n">needsJoinPrepare</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="n">heartbeatTask</span><span class="o">.</span><span class="na">reset</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// we handle failures below after the request finishes. if the join completes
</span><span class="c1"></span>        <span class="c1">// after having been woken up, the exception is ignored and we will rejoin
</span><span class="c1"></span>    <span class="o">}</span>
<span class="o">}</span><span class="o">)</span><span class="o">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这个参数value就是上面的syncResponse.memberAssignment()返回值。这里的onJoinComplete方法主要就是更新每个consumer的assignment信息。</p>
<p>至此整个ConsumerCoordinator所做的事情分析完毕。</p>
<h3 id="fetcher">Fetcher</h3>
<p>pollOnce方法中的第三步和第四步比较简单，直接跳过。后面的几步，可以看到出现了两次拉取消息的操作，这是因为IO模型为异步，所以这样做会提高效率。而client.poll方法上面已经分析过。因此这需要分析构造请求的过程sendFetches方法，以及拉取消息的fetchedRecords方法。</p>
<p>构造请求的套路与之前一致。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">sendFetches</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">&gt;</span> <span class="n">fetchEntry</span><span class="o">:</span> <span class="n">createFetchRequests</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">final</span> <span class="n">FetchRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="n">fetchEntry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">client</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">fetchEntry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">ApiKeys</span><span class="o">.</span><span class="na">FETCH</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="k">new</span> <span class="n">RequestFutureListener</span><span class="o">&lt;</span><span class="n">ClientResponse</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">FetchResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FetchResponse</span><span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">responseBody</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                        <span class="n">Set</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">&gt;</span> <span class="n">partitions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">responseData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">keySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                        <span class="n">FetchResponseMetricAggregator</span> <span class="n">metricAggregator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FetchResponseMetricAggregator</span><span class="o">(</span><span class="n">sensors</span><span class="o">,</span> <span class="n">partitions</span><span class="o">)</span><span class="o">;</span>

                        <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">FetchResponse</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">response</span><span class="o">.</span><span class="na">responseData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">TopicPartition</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                            <span class="kt">long</span> <span class="n">fetchOffset</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">fetchData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">partition</span><span class="o">)</span><span class="o">.</span><span class="na">offset</span><span class="o">;</span>
                            <span class="n">FetchResponse</span><span class="o">.</span><span class="na">PartitionData</span> <span class="n">fetchData</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                            <span class="n">completedFetches</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">CompletedFetch</span><span class="o">(</span><span class="n">partition</span><span class="o">,</span> <span class="n">fetchOffset</span><span class="o">,</span> <span class="n">fetchData</span><span class="o">,</span> <span class="n">metricAggregator</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                        <span class="o">}</span>

                        <span class="n">sensors</span><span class="o">.</span><span class="na">fetchLatency</span><span class="o">.</span><span class="na">record</span><span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">requestLatencyMs</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                        <span class="n">sensors</span><span class="o">.</span><span class="na">fetchThrottleTimeSensor</span><span class="o">.</span><span class="na">record</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">getThrottleTime</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="nd">@Override</span>
                    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onFailure</span><span class="o">(</span><span class="n">RuntimeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">log</span><span class="o">.</span><span class="na">debug</span><span class="o">(</span><span class="s">&#34;Fetch failed&#34;</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法中用createFetchRequests方法构造了请求，然后循环将请求放到了unsent队列。同时还添加了监听器，定义了处理响应的逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">&gt;</span> <span class="nf">createFetchRequests</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// create the fetch info
</span><span class="c1"></span>    <span class="n">Cluster</span> <span class="n">cluster</span> <span class="o">=</span> <span class="n">metadata</span><span class="o">.</span><span class="na">fetch</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">fetchable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">TopicPartition</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">fetchablePartitions</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">cluster</span><span class="o">.</span><span class="na">leaderFor</span><span class="o">(</span><span class="n">partition</span><span class="o">)</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">node</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">metadata</span><span class="o">.</span><span class="na">requestUpdate</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">client</span><span class="o">.</span><span class="na">pendingRequestCount</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="o">=</span><span class="o">=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// if there is a leader and no in-flight requests, issue a new fetch
</span><span class="c1"></span>            <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">&gt;</span> <span class="n">fetch</span> <span class="o">=</span> <span class="n">fetchable</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">)</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">fetch</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">fetch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">fetchable</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">fetch</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="kt">long</span> <span class="n">position</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">partition</span><span class="o">)</span><span class="o">;</span>
            <span class="n">fetch</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">partition</span><span class="o">,</span> <span class="k">new</span> <span class="n">FetchRequest</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">(</span><span class="n">position</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">fetchSize</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="n">log</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">&#34;Added fetch request for partition {} at offset {}&#34;</span><span class="o">,</span> <span class="n">partition</span><span class="o">,</span> <span class="n">position</span><span class="o">)</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="c1">// create the fetches
</span><span class="c1"></span>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">&gt;</span> <span class="n">requests</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">FetchRequest</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">fetchable</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">FetchRequest</span> <span class="n">fetch</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FetchRequest</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">maxWaitMs</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">minBytes</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
        <span class="n">requests</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">fetch</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">requests</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>整个过程与Producer端发送请求的思路类似，以一个节点为单位发送请求。这个节点包含多个TopicPartition，请求中会包含每个TopicPartition的最新消费情况和想要拉取数据的大小，以便Kafka Server知道该请求想要从哪里开始拉取数据并拉取多少。</p>
<p>接下来分析监听器onSuccess方法的逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSuccess</span><span class="o">(</span><span class="n">ClientResponse</span> <span class="n">resp</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">FetchResponse</span> <span class="n">response</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FetchResponse</span><span class="o">(</span><span class="n">resp</span><span class="o">.</span><span class="na">responseBody</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">&gt;</span> <span class="n">partitions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">response</span><span class="o">.</span><span class="na">responseData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">keySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="n">FetchResponseMetricAggregator</span> <span class="n">metricAggregator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">FetchResponseMetricAggregator</span><span class="o">(</span><span class="n">sensors</span><span class="o">,</span> <span class="n">partitions</span><span class="o">)</span><span class="o">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">FetchResponse</span><span class="o">.</span><span class="na">PartitionData</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">response</span><span class="o">.</span><span class="na">responseData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">entrySet</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">TopicPartition</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">fetchOffset</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">fetchData</span><span class="o">(</span><span class="o">)</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">partition</span><span class="o">)</span><span class="o">.</span><span class="na">offset</span><span class="o">;</span>
        <span class="n">FetchResponse</span><span class="o">.</span><span class="na">PartitionData</span> <span class="n">fetchData</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="n">completedFetches</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">CompletedFetch</span><span class="o">(</span><span class="n">partition</span><span class="o">,</span> <span class="n">fetchOffset</span><span class="o">,</span> <span class="n">fetchData</span><span class="o">,</span> <span class="n">metricAggregator</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span>
  
  <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
    
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其逻辑就是将响应中包含的消息提取出来，构造一个CompleteFetch对象，放入completedFetches列表中。由此可以推测出，fetchedRecords方法就是从这个列表中取出数据。</p>
<p>至此分析完了sendFetches方法，来看看fetchedRecords方法是不是在做这样的事。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="nf">fetchedRecords</span><span class="o">(</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">subscriptions</span><span class="o">.</span><span class="na">partitionAssignmentNeeded</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">Collections</span><span class="o">.</span><span class="na">emptyMap</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">Map</span><span class="o">&lt;</span><span class="n">TopicPartition</span><span class="o">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">drained</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">recordsRemaining</span> <span class="o">=</span> <span class="n">maxPollRecords</span><span class="o">;</span>
        <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">CompletedFetch</span><span class="o">&gt;</span> <span class="n">completedFetchesIterator</span> <span class="o">=</span> <span class="n">completedFetches</span><span class="o">.</span><span class="na">iterator</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">recordsRemaining</span> <span class="o">&gt;</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">nextInLineRecords</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span> <span class="o">|</span><span class="o">|</span> <span class="n">nextInLineRecords</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">completedFetchesIterator</span><span class="o">.</span><span class="na">hasNext</span><span class="o">(</span><span class="o">)</span><span class="o">)</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="n">CompletedFetch</span> <span class="n">completion</span> <span class="o">=</span> <span class="n">completedFetchesIterator</span><span class="o">.</span><span class="na">next</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">completedFetchesIterator</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="n">nextInLineRecords</span> <span class="o">=</span> <span class="n">parseFetchedData</span><span class="o">(</span><span class="n">completion</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">recordsRemaining</span> <span class="o">-</span><span class="o">=</span> <span class="n">append</span><span class="o">(</span><span class="n">drained</span><span class="o">,</span> <span class="n">nextInLineRecords</span><span class="o">,</span> <span class="n">recordsRemaining</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">drained</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>直接看else分支，的确是在处理该列表。while循环不断处理每一条数据。parseFetchedData对数据进行解析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="n">PartitionRecords</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="nf">parseFetchedData</span><span class="o">(</span><span class="n">CompletedFetch</span> <span class="n">completedFetch</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">TopicPartition</span> <span class="n">tp</span> <span class="o">=</span> <span class="n">completedFetch</span><span class="o">.</span><span class="na">partition</span><span class="o">;</span>
    <span class="n">FetchResponse</span><span class="o">.</span><span class="na">PartitionData</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">completedFetch</span><span class="o">.</span><span class="na">partitionData</span><span class="o">;</span>
    <span class="kt">long</span> <span class="n">fetchOffset</span> <span class="o">=</span> <span class="n">completedFetch</span><span class="o">.</span><span class="na">fetchedOffset</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">recordsCount</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="n">PartitionRecords</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">parsedRecords</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">subscriptions</span><span class="o">.</span><span class="na">isFetchable</span><span class="o">(</span><span class="n">tp</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
          
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
            
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">partition</span><span class="o">.</span><span class="na">errorCode</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NONE</span><span class="o">.</span><span class="na">code</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">Long</span> <span class="n">position</span> <span class="o">=</span> <span class="n">subscriptions</span><span class="o">.</span><span class="na">position</span><span class="o">(</span><span class="n">tp</span><span class="o">)</span><span class="o">;</span>
          
          <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>

            <span class="n">ByteBuffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="na">recordSet</span><span class="o">;</span>
            <span class="n">MemoryRecords</span> <span class="n">records</span> <span class="o">=</span> <span class="n">MemoryRecords</span><span class="o">.</span><span class="na">readableRecords</span><span class="o">(</span><span class="n">buffer</span><span class="o">)</span><span class="o">;</span>
            <span class="n">List</span><span class="o">&lt;</span><span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span><span class="o">&gt;</span> <span class="n">parsed</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="kt">boolean</span> <span class="n">skippedRecords</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">for</span> <span class="o">(</span><span class="n">LogEntry</span> <span class="n">logEntry</span> <span class="o">:</span> <span class="n">records</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">logEntry</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span><span class="o">=</span> <span class="n">position</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 反序列化消息。
</span><span class="c1"></span>                    <span class="n">parsed</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">parseRecord</span><span class="o">(</span><span class="n">tp</span><span class="o">,</span> <span class="n">logEntry</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
                    <span class="n">bytes</span> <span class="o">+</span><span class="o">=</span> <span class="n">logEntry</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="n">skippedRecords</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="n">recordsCount</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">sensors</span><span class="o">.</span><span class="na">recordTopicFetchMetrics</span><span class="o">(</span><span class="n">tp</span><span class="o">.</span><span class="na">topic</span><span class="o">(</span><span class="o">)</span><span class="o">,</span> <span class="n">bytes</span><span class="o">,</span> <span class="n">recordsCount</span><span class="o">)</span><span class="o">;</span>

            <span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">parsed</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">&#34;Adding fetched record for partition {} with offset {} to buffered record list&#34;</span><span class="o">,</span> <span class="n">tp</span><span class="o">,</span> <span class="n">position</span><span class="o">)</span><span class="o">;</span>
                <span class="n">parsedRecords</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PartitionRecords</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">fetchOffset</span><span class="o">,</span> <span class="n">tp</span><span class="o">,</span> <span class="n">parsed</span><span class="o">)</span><span class="o">;</span>
                <span class="n">ConsumerRecord</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">record</span> <span class="o">=</span> <span class="n">parsed</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">parsed</span><span class="o">.</span><span class="na">size</span><span class="o">(</span><span class="o">)</span> <span class="o">-</span> <span class="n">1</span><span class="o">)</span><span class="o">;</span>
                <span class="k">this</span><span class="o">.</span><span class="na">sensors</span><span class="o">.</span><span class="na">recordsFetchLag</span><span class="o">.</span><span class="na">record</span><span class="o">(</span><span class="n">partition</span><span class="o">.</span><span class="na">highWatermark</span> <span class="o">-</span> <span class="n">record</span><span class="o">.</span><span class="na">offset</span><span class="o">(</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">buffer</span><span class="o">.</span><span class="na">limit</span><span class="o">(</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;</span><span class="o">&amp;</span> <span class="o">!</span><span class="n">skippedRecords</span><span class="o">)</span> <span class="o">{</span>
              
              <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
                
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">partition</span><span class="o">.</span><span class="na">errorCode</span> <span class="o">=</span><span class="o">=</span> <span class="n">Errors</span><span class="o">.</span><span class="na">NOT_LEADER_FOR_PARTITION</span><span class="o">.</span><span class="na">code</span><span class="o">(</span><span class="o">)</span>
                   
                   <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
                   
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        
      <span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span><span class="o">.</span>
        
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">parsedRecords</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中的parseRecord方法就是用序列化器对数据进行反序列化。最后将所有数据封装到parsedRecords对象中返回。</p>
<p>append方法会建立TopicPartition与消息的关系，比较简单，不展开讨论。</p>
<p>至此与Fetcher有关的操作都已分析完毕。pollOnce的整个流程结束。</p>
<h3 id="poll方法中的if分支">poll方法中的if分支</h3>
<p>在pollOnce方法下面有一个if分支，之前没有分析为什么会出现该分支。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="k">if</span> <span class="o">(</span><span class="o">!</span><span class="n">records</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">(</span><span class="o">)</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">fetcher</span><span class="o">.</span><span class="na">sendFetches</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>
    <span class="n">client</span><span class="o">.</span><span class="na">pollNoWakeup</span><span class="o">(</span><span class="o">)</span><span class="o">;</span>

    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">interceptors</span> <span class="o">=</span><span class="o">=</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">records</span><span class="o">)</span><span class="o">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">interceptors</span><span class="o">.</span><span class="na">onConsume</span><span class="o">(</span><span class="k">new</span> <span class="n">ConsumerRecords</span><span class="o">&lt;</span><span class="o">&gt;</span><span class="o">(</span><span class="n">records</span><span class="o">)</span><span class="o">)</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>现在已经了解了fetcher对象的作用，也知道了client.pollNoWakeup方法的作用（与poll类似）。这个分支存在的目的，也是因为IO是异步模型，当接收到消息时，可以先不急着处理，而是进入这个if分支，再次发送一个请求出去，然后再做业务处理。当业务处理结束再次进入到pollOnce方法时，响应可能就已经到了，刚好可以处理。</p>
<h2 id="总结">总结</h2>
<p>Consumer端与Producer端用了同样的网络IO模型，有大量的代码复用。</p>
<p>流程上来说，先是通过coordinator完成消费者的分配，即哪个consumer消费哪些TopicPartition。期间会发送多个请求，处理多个响应。然后发送请求拉取消息，收到消息响应后解析并返回给业务代码。</p>
<p>从设计上来说，主要关注每个请求发送过后都会给返回的future对象添加监听器，定义了处理响应的逻辑。其中用到了适配器模式，值得学习。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Weizhe Huang</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-03-31
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/%E5%A4%A7%E6%95%B0%E6%8D%AE/kafka/%E6%B7%B1%E5%85%A5kafka%E6%BA%90%E7%A0%81-producer%E7%AB%AF%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B/">
            <span class="next-text nav-default">深入Kafka源码 - Producer端发送数据全流程</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://localhost:1313" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://localhost:1313" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="http://localhost:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Weizhe Huang</span>
  </span>
</div>


<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({ tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]} })
</script>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.26188efa.min.js"></script>








</body>
</html>
